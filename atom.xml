<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ArchitecTang Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://architectang.github.io/"/>
  <updated>2019-07-17T13:24:17.019Z</updated>
  <id>https://architectang.github.io/</id>
  
  <author>
    <name>ITboy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是wifi探针??</title>
    <link href="https://architectang.github.io/2019/07/17/%E4%BB%80%E4%B9%88%E6%98%AFwifi%E6%8E%A2%E9%92%88/"/>
    <id>https://architectang.github.io/2019/07/17/什么是wifi探针/</id>
    <published>2019-07-17T12:59:09.000Z</published>
    <updated>2019-07-17T13:24:17.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p><img src="https://i.loli.net/2019/07/17/5d2f21583ba4a77704.png" alt="wifi探针.png"></p><h6 id="1、什么是WIFI探针？？"><a href="#1、什么是WIFI探针？？" class="headerlink" title="1、什么是WIFI探针？？"></a>1、什么是WIFI探针？？</h6><p>WIFI 探针是一种能够主动识别 Android 和 IOS 设备，感知用户行为轨迹的精准数据收集前端，基于 WIFI探测技术、移动互联网和云计算等先进技术自动识别探针附近的智能移动终端。<br>、<br>当一个设备给另外一个设备通过无线传输技术发送信息时，周围的其他同类设备都是能够收到无线信息，WiFi探针技术基于此原理。</p><p>具体说，当WiFi设备在WiFi探针的侦听范围内，WiFi设备（无论是终端、路由器或者其他WiFi设备）发送任何一帧（Frame）时，不管是发给谁，探针都能截获，并分析出此帧MAC层与物理层的一些信息，比如发送与接收设备的MAC地址、帧类型、信号强度等。</p><p>WiFi探针不需要与周围的设备有任何交互，其本身不发出任何WiFi信号，即实现了无感知获取MAC信息。</p><h6 id="2、WIFI探针特点"><a href="#2、WIFI探针特点" class="headerlink" title="2、WIFI探针特点"></a>2、WIFI探针特点</h6><p>●用户无需连接，无需安装APP；</p><p>●手机已经连接WiFi也可以探测；</p><p>●自动实时探测区域内的WiFi终端标识MAC地址；</p><p>●自动记录每个WiFi终端进入区域时间log_TIme、场强SNR；</p><p>●兼容iOS苹果和Android系统，开启WiFi的智能手机、笔记本电脑、Pad等移动设备都能探测。</p><h6 id="3、WIFI-探针技术所使用的网络协议"><a href="#3、WIFI-探针技术所使用的网络协议" class="headerlink" title="3、WIFI 探针技术所使用的网络协议"></a>3、WIFI 探针技术所使用的网络协议</h6><p>WIFI探针所采用的网络协议是IEEE802.11协议集，此协议集包含许多子协议。其中按照时间顺序发展，主要有：</p><p>（1）802.11a</p><p>（2）802.11b</p><p>（3）802.11g</p><p>（4）802.11n</p><p>在网络通信中，数据被封装成了帧（通信中的一个数据块）。帧在数据链路层传输的时候是有固定格式的，不是随便的封装和打包就可以传输。大小有限制，最小46字节，最大1500字节。</p><h6 id="4、WIFI-探针原理"><a href="#4、WIFI-探针原理" class="headerlink" title="4、WIFI 探针原理"></a>4、WIFI 探针原理</h6><p>wifi探针实际上指的是probe帧。我们一般接入无线网络的时候，首先要选择对应的无线网路，即根据无线网络的名字进行选择（SSID）。那么知道这个名字有两种方式，主动扫描和被动扫描，其中probe帧即是用在主动扫描这种技术中。</p><p>具体原理：</p><p>节点会主动的发送probe request请求帧给AP（路由），AP然后反馈响应probe response，该probe response帧和Beacon的内容几乎是一致的，之后利用该帧中的一些信息，节点才会继续发起接入过程。所以狭义上而言，探针技术是一个帧，也是一种节点收集AP信息的方法。</p><p>AP实际上也可以用来收集节点的信息，该信息并不是指节点（即用户的终端，比如手机）内部的一些信息，而是一些移动的痕迹。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="物联网" scheme="https://architectang.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="物联网" scheme="https://architectang.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>docker 仓库harbor搭建</title>
    <link href="https://architectang.github.io/2019/07/12/docker-%E4%BB%93%E5%BA%93harbor%E6%90%AD%E5%BB%BA/"/>
    <id>https://architectang.github.io/2019/07/12/docker-仓库harbor搭建/</id>
    <published>2019-07-12T09:14:30.000Z</published>
    <updated>2019-07-12T12:01:24.274Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h5><p>在正式安装harbor之前，需要对OS环境进行初始化</p><h6 id="1-1-升级OS内核，具体内核升级步骤可以自己了解下"><a href="#1-1-升级OS内核，具体内核升级步骤可以自己了解下" class="headerlink" title="1.1 升级OS内核，具体内核升级步骤可以自己了解下"></a>1.1 升级OS内核，具体内核升级步骤可以自己了解下</h6><h6 id="1-2-安装yum源"><a href="#1-2-安装yum源" class="headerlink" title="1.2 安装yum源"></a>1.2 安装yum源</h6><p>因为需要安装相关的以来软件，所以需要安装yum源，安装前先将原先的yum备份</p><pre><code>[root@harbor yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.bak[root@harbor yum.repos.d]# vim CentOS-Base.repo[base]name=CentOS-$releasever – Base – 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever – Updates – 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesbaseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever – Extras – 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasbaseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever – Plus – 163.combaseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</code></pre><p><img src="https://i.loli.net/2019/07/12/5d2850a00566f24895.png" alt="epel.png"></p><h6 id="1-3-安装阿里云epel源"><a href="#1-3-安装阿里云epel源" class="headerlink" title="1.3 安装阿里云epel源"></a>1.3 安装阿里云epel源</h6><pre><code>wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></pre><p><img src="https://i.loli.net/2019/07/12/5d28510e95a7b40843.png" alt="安装epel.png"></p><h6 id="1-4-安装docker"><a href="#1-4-安装docker" class="headerlink" title="1.4 安装docker"></a>1.4 安装docker</h6><pre><code>yum -y install docker</code></pre><p>启动docker并查看docker版本<br><img src="https://i.loli.net/2019/07/12/5d2851689228260891.png" alt="安装docker.png"></p><h6 id="1-5-安装docker-compose"><a href="#1-5-安装docker-compose" class="headerlink" title="1.5 安装docker-compose"></a>1.5 安装docker-compose</h6><pre><code>yum -y install certbot libevent-devel gcc libffi-devel python-devel openssl-devel python2-pip</code></pre><p>使用pip的方式进行安装，命令如下</p><pre><code>pip install -U docker-compose</code></pre><p><img src="https://i.loli.net/2019/07/12/5d2851bd5d99095382.png" alt="dockercompose.png"><br>查看安装的版本</p><pre><code>docker-compose version</code></pre><p><img src="https://i.loli.net/2019/07/12/5d2851ed6e9fd60328.png" alt="查看安装.png"></p><h5 id="二、下载安装harbor，选择自己需要的版本"><a href="#二、下载安装harbor，选择自己需要的版本" class="headerlink" title="二、下载安装harbor，选择自己需要的版本"></a>二、下载安装harbor，选择自己需要的版本</h5><p>官网地址：<a href="http://harbor.orientsoft.cn/" target="_blank" rel="noopener">http://harbor.orientsoft.cn/</a><br><img src="https://i.loli.net/2019/07/12/5d2852421d18d60335.png" alt="Harbor.png"></p><h6 id="2-1-修改Harbor配置文件，修改服务地址"><a href="#2-1-修改Harbor配置文件，修改服务地址" class="headerlink" title="2.1 修改Harbor配置文件，修改服务地址"></a>2.1 修改Harbor配置文件，修改服务地址</h6><pre><code>[root@harbor ~]# lsanaconda-ks.cfg  harbor-offline-installer-v1.4.0.tgz[root@harbor ~]# tar xf harbor-offline-installer-v1.4.0.tgz [root@harbor ~]# lsanaconda-ks.cfg  harbor  harbor-offline-installer-v1.4.0.tgz[root@harbor ~]# mv harbor /usr/local/[root@harbor ~]# vim harbor.cfg</code></pre><p>修改hostname为主机的IP（没有域名的情况下）<br><img src="https://i.loli.net/2019/07/12/5d2852fc2cd6988291.png" alt="修改hostsname.png"></p><h6 id="2-2-修改harbor的默认admin密码（默认密码为Harbor12345）"><a href="#2-2-修改harbor的默认admin密码（默认密码为Harbor12345）" class="headerlink" title="2.2 修改harbor的默认admin密码（默认密码为Harbor12345）"></a>2.2 修改harbor的默认admin密码（默认密码为Harbor12345）</h6><p><img src="https://i.loli.net/2019/07/12/5d28535b2963447635.png" alt="修改Harbor默认密码.png"></p><h6 id="2-3-安装harbor"><a href="#2-3-安装harbor" class="headerlink" title="2.3 安装harbor"></a>2.3 安装harbor</h6><p><img src="https://i.loli.net/2019/07/12/5d2853818460889055.png" alt="安装.png"><br>步骤一会下载相关的docker镜像，这个过程根据各自的网络情况不同花费的时间也不同，相关的docker镜像如下：</p><pre><code>docker images</code></pre><p><img src="https://i.loli.net/2019/07/12/5d2853b91656a11429.png" alt="dockerimages.png"></p><h6 id="2-4-查看容器，可以看到没有Notary与Clair相关服务；也可使用”docker-ps”；"><a href="#2-4-查看容器，可以看到没有Notary与Clair相关服务；也可使用”docker-ps”；" class="headerlink" title="2.4 查看容器，可以看到没有Notary与Clair相关服务；也可使用”docker ps”；"></a>2.4 查看容器，可以看到没有Notary与Clair相关服务；也可使用”docker ps”；</h6><p>“docker-compose ps”需要在”docker-compose.yml”文件所在目录执行相关操作</p><pre><code>[root@harbor harbor]# docker-compose ps</code></pre><p><img src="https://i.loli.net/2019/07/12/5d2853fe445b964442.png" alt="dockerps.png"></p><h5 id="三、安装后配置"><a href="#三、安装后配置" class="headerlink" title="三、安装后配置"></a>三、安装后配置</h5><h6 id="3-1-访问harbor-ui-（注意服务器的防火墙和selinux，可以关闭或者放行相关端口）admin-默认密码"><a href="#3-1-访问harbor-ui-（注意服务器的防火墙和selinux，可以关闭或者放行相关端口）admin-默认密码" class="headerlink" title="3.1 访问harbor ui  （注意服务器的防火墙和selinux，可以关闭或者放行相关端口）admin/默认密码"></a>3.1 访问harbor ui （注意服务器的防火墙和selinux，可以关闭或者放行相关端口）admin/默认密码</h6><p><img src="https://i.loli.net/2019/07/12/5d28543a3a18690521.png" alt="登陆.png"><br>harbor安装完成<br><img src="https://i.loli.net/2019/07/12/5d285467ed7a348734.png" alt="登陆2.png"></p><h6 id="3-2-harbor-使用docker-login报错的问题"><a href="#3-2-harbor-使用docker-login报错的问题" class="headerlink" title="3.2 harbor 使用docker login报错的问题"></a>3.2 harbor 使用docker login报错的问题</h6><p><img src="https://i.loli.net/2019/07/12/5d28549b523cf57301.png" alt="登陆报错.png"><br>从harbor安装文档中可以看到<a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">https://github.com/vmware/harbor/blob/master/docs/installation_guide.md</a><br><img src="https://i.loli.net/2019/07/12/5d2854e03c93357954.png" alt="报错排查.png"><br>在Harbor主机和客户机都对这个文件进行设置/etc/docker/daemon.json：</p><pre><code>{ &quot;insecure-registries&quot;:[&quot;192.168.33.10&quot;] }</code></pre><p><img src="https://i.loli.net/2019/07/12/5d28551d6227692895.png" alt="报错解决.png"></p><h5 id="四、简单使用"><a href="#四、简单使用" class="headerlink" title="四、简单使用"></a>四、简单使用</h5><h6 id="4-1-向harbor上推拉镜象"><a href="#4-1-向harbor上推拉镜象" class="headerlink" title="4.1 向harbor上推拉镜象"></a>4.1 向harbor上推拉镜象</h6><p>给docker.io/tomcat这个镜像打上tag</p><pre><code>[root@harbor ~]# docker tag docker.io/tomcat 172.31.8.25/library/tomcat2</code></pre><p><img src="https://i.loli.net/2019/07/12/5d28555f2525562448.png" alt="镜像推送.png"></p><h6 id="4-2-推送至harbor"><a href="#4-2-推送至harbor" class="headerlink" title="4.2 推送至harbor"></a>4.2 推送至harbor</h6><pre><code>[root@harbor ~]# docker push 172.31.8.25/library/tomcat2</code></pre><p><img src="https://i.loli.net/2019/07/12/5d28558b0c6d544922.png" alt="推送.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客使用Next主题建立标签云</title>
    <link href="https://architectang.github.io/2019/07/10/Hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98%E5%BB%BA%E7%AB%8B%E6%A0%87%E7%AD%BE%E4%BA%91/"/>
    <id>https://architectang.github.io/2019/07/10/Hexo博客使用Next主题建立标签云/</id>
    <published>2019-07-10T11:49:17.000Z</published>
    <updated>2019-07-10T13:09:17.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>使用hexo-tag-cloud插件:<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">github地址</a></p><h6 id="1、安装插件"><a href="#1、安装插件" class="headerlink" title="1、安装插件:"></a>1、安装插件:</h6><p>进入到hexo的根目录，在在 package.json 中添加依赖: “hexo-tag-cloud”: “2.0.*” 操作如下：</p><pre><code>npm install hexo-tag-cloud@^2.0.* --save </code></pre><p>Git clone 下载<br>使用命令行安装插件包的过程中可能会出现问题，安装失败，安装不完全。可以直接克隆插件到博客的插件文件夹blog/node_modules里。或者克隆到桌面然后复制到博客的插件目录</p><p>blog\node_modules文件夹里</p><pre><code>git clone https://github.com/MikeCoder/hexo-tag-cloud</code></pre><p><img src="https://i.loli.net/2019/07/10/5d25d3055c48522209.png" alt="插件所在路径.png"></p><h6 id="2、配置插件"><a href="#2、配置插件" class="headerlink" title="2、配置插件"></a>2、配置插件</h6><p>插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。我这里使用的next主题，所以使用的是swig 配置方式（不仅next，还有其他主题的配置文件也是.swig格式）</p><p>在主题文件夹找到文件 theme/next/layout/_macro/sidebar.swig, 然后写入如下代码</p><p><a href="https://github.com/MikeCoder/hexo-tag-cloud#for-swig-users" target="_blank" rel="noopener">跳转官网复制代码</a></p><p>添加到合适的位置即可<br><img src="https://i.loli.net/2019/07/10/5d25d43a0d58481617.png" alt="tagcloud写入位置.png"><br>博客根目录找到 _config.yml配置文件,在最后添加以下的配置项</p><pre><code># hexo-tag-cloudtag_cloud:    textFont: Trebuchet MS, Helvetica    textColor: &apos;#333&apos;    textHeight: 25    outlineColor: &apos;#E2E1D1&apos;    maxSpeed: 0.1</code></pre><p>定义标签云的字体和颜色</p><pre><code>textColor: ‘#333’ 字体颜色textHeight: 25 字体高度，根据部署的效果调整maxSpeed: 0.1 文字滚动速度，根据自己喜好调整</code></pre><p>重启博客，部署到线上</p><pre><code>hexo clean   清除缓存hexo g  生成博客hexo s  本地预览hexo d  部署到线上一定要注意清除缓存，不然的话容易出现功能效果不展示的问题，清除缓存即执行:hexo clean</code></pre><p>实现效果<br><img src="https://i.loli.net/2019/07/10/5d25d477c5e9b22737.png" alt="实现效果.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="hexo博客建站" scheme="https://architectang.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="HEXO博客建站" scheme="https://architectang.github.io/tags/HEXO%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用网络工具:fping主机扫描</title>
    <link href="https://architectang.github.io/2019/07/10/Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7-fping%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/"/>
    <id>https://architectang.github.io/2019/07/10/Linux常用网络工具-fping主机扫描/</id>
    <published>2019-07-10T08:10:52.000Z</published>
    <updated>2019-07-14T18:34:54.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="fping-介绍"><a href="#fping-介绍" class="headerlink" title="fping 介绍"></a>fping 介绍</h5><p>Linux下有很多强大网络扫描工具，网络扫描工具可以分为：主机扫描、主机服务扫描、路由扫描等。</p><p>fping是一个主机扫描工具，相比于ping工具它可以批量扫描主机。</p><p>fping完全不同于ping，因为您可以在命令行上定义任意数量的主机，或者指定包含要ping的IP地址或主机列表的文件。</p><p>例如，使用fping，我们可以指定完整的网络范围（ 192.168.0.1/24 ）。<br>它会向主机发送Fping请求，并以循环方式移动到另一个目标主机。 与ping不同，Fping基本上用于编写脚本。</p><p>访问<a href="http://fping.org/" target="_blank" rel="noopener">fping 官方网站：http://fping.org</a>下载最新版安装程序<br><img src="https://i.loli.net/2019/07/13/5d29927105a8756317.png" alt="官网.png"></p><h5 id="一、编译及安装"><a href="#一、编译及安装" class="headerlink" title="一、编译及安装"></a>一、编译及安装</h5><p>安装可以使用yum安装或者源码安装</p><p>yum 安装命令:</p><pre><code>yum install fping非root用户可使用sudo或者切换到root用户安装sudo yum install fping</code></pre><p>源码安装</p><pre><code>[root@node1 ~]# wget http://fping.org/dist/fping-4.2.tar.gz[root@node1 ~]# ll fping-4.2.tar.gz -rw-r--r--. 1 root root 171409 2月  20 05:05 fping-4.2.tar.gz[root@node1 ~]# tar xf fping-4.2.tar.gz &amp;&amp; cd fping-4.2[root@node1 fping-4.2]# ./configure &amp;&amp; make &amp;&amp; make install</code></pre><p><img src="https://i.loli.net/2019/07/13/5d299476e2bf846559.png" alt="f拼.png"><br>查看安装版本</p><pre><code>fping -v</code></pre><p><img src="https://i.loli.net/2019/07/13/5d2994f0599be62290.png" alt="VERSION.png"></p><h5 id="二、使用示例"><a href="#二、使用示例" class="headerlink" title="二、使用示例"></a>二、使用示例</h5><h6 id="2-1-ping多个主机"><a href="#2-1-ping多个主机" class="headerlink" title="2.1 ping多个主机"></a>2.1 ping多个主机</h6><pre><code>[root@node1 fping-4.2]# fping 172.31.8.13 172.31.8.107 172.31.8.75 172.31.8.3172.31.8.13 is alive    ---主机活动172.31.8.107 is alive172.31.8.75 is alive172.31.8.75 is unreachable  --- 主机不可用[root@node1 fping-4.2]# </code></pre><h6 id="2-2-ping-IP地址范围"><a href="#2-2-ping-IP地址范围" class="headerlink" title="2.2 ping IP地址范围"></a>2.2 ping IP地址范围</h6><p>以下命令将接收ping的IP范围并输出以下内容，我们将响应请求发送到该范围内的IP并获得我们想要信息。结束后还显示累积结果</p><pre><code>[root@node1 fping-4.2]# fping -s -g 172.31.8.1 172.31.8.10172.31.8.1 is alive172.31.8.3 is alive172.31.8.5 is alive172.31.8.8 is aliveICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.2ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.2ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.2ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.2ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.4ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.4ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.4ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.4ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.6ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.6ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.6ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.6ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.7ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.7ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.7ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.7ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.9ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.9ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.9ICMP Host Unreachable from 172.31.8.8 for ICMP Echo sent to 172.31.8.9172.31.8.2 is unreachable172.31.8.4 is unreachable172.31.8.6 is unreachable172.31.8.7 is unreachable172.31.8.9 is unreachable172.31.8.10 is unreachable    10 targets    4 alive    6 unreachable    0 unknown addresses    6 timeouts (waiting for response)    28 ICMP Echos sent    4 ICMP Echo Replies received    20 other ICMP received0.04 ms (min round trip time)0.73 ms (avg round trip time)1.15 ms (max round trip time)        4.164 sec (elapsed real time)[root@node1 fping-4.2]# </code></pre><h6 id="2-3-ping整个IP段，并重复一次"><a href="#2-3-ping整个IP段，并重复一次" class="headerlink" title="2.3 ping整个IP段，并重复一次"></a>2.3 ping整个IP段，并重复一次</h6><p><img src="https://i.loli.net/2019/07/13/5d299ad356d1f34442.png" alt="测试.png"></p><h6 id="2-4-从文件中读取IP信息，执行ping"><a href="#2-4-从文件中读取IP信息，执行ping" class="headerlink" title="2.4 从文件中读取IP信息，执行ping"></a>2.4 从文件中读取IP信息，执行ping</h6><p><img src="https://i.loli.net/2019/07/13/5d299b826503647681.png" alt="测试2.png"></p><h5 id="三、查看帮助信息"><a href="#三、查看帮助信息" class="headerlink" title="三、查看帮助信息"></a>三、查看帮助信息</h5><pre><code>[root@node1 fping-4.2]# fping -helpUsage: fping [options] [targets...]用法：fping [选项] [ping的目标]-a         show targets that are alive            显示可ping通的目标-A         show targets by address            将目标以ip地址的形式显示-b n       amount of ping data to send, in bytes (default 56)            ping 数据包的大小。（默认为56）-B f       set exponential backoff factor to f            设置指数反馈因子到f-c n       count of pings to send to each target (default 1)                ping每个目标的次数 (默认为1)-C n       same as -c, report results in verbose format                同-c, 返回的结果为冗长格式-e         show elapsed time on return packets                显示返回数据包所费时间-f file    read list of targets from a file ( - means stdin) (only if no -g specified)            从文件获取目标列表( - 表示从标准输入)(不能与 -g 同时使用)-g         generate target list (only if no -f specified)            生成目标列表(不能与 -f 同时使用)                (specify the start and end IP in the target list, or supply a IP netmask)                (ex. fping -g 192.168.1.0 192.168.1.255 or fping -g 192.168.1.0/24)                (可指定目标的开始和结束IP， 或者提供ip的子网掩码)                (例：fping -g 192.168.1.0 192.168.1.255 或 fping -g 192.168.1.0/24)-H n       Set the IP TTL value (Time To Live hops)                设置ip的TTL值 (生存时间)-i n       interval between sending ping packets (in millisec) (default 25)            ping包之间的间隔(单位：毫秒)(默认25)-l         loop sending pings forever            循环发送ping-m         ping multiple interfaces on target host                ping目标主机的多个网口-n         show targets by name (-d is equivalent)                将目标以主机名或域名显示(等价于 -d )-p n       interval between ping packets to one target (in millisec)                对同一个目标的ping包间隔(毫秒)                (in looping and counting modes, default 1000)                (在循环和统计模式中，默认为1000)-q         quiet (don&apos;t show per-target/per-ping results)            安静模式(不显示每个目标或每个ping的结果)-Q n       same as -q, but show summary every n seconds            同-q, 但是每n秒显示信息概要-r n       number of retries (default 3)            当ping失败时，最大重试次数(默认为3次)-s         print final stats            打印最后的统计数据-I if      bind to a particular interface            绑定到特定的网卡-S addr    set source address                设置源ip地址-t n       individual target initial timeout (in millisec) (default 500)            单个目标的超时时间(毫秒)(默认500)-T n       ignored (for compatibility with fping 2.4)                请忽略(为兼容fping 2.4)-u         show targets that are unreachable                显示不可到达的目标-O n       set the type of service (tos) flag on the ICMP packets                在icmp包中设置tos（服务类型）-v         show version                显示版本号targets    list of targets to check (if no -f specified)                需要ping的目标列表(不能和 -f 同时使用)-h              show this page                显示本帮助页</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络" scheme="https://architectang.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://architectang.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>tomcat 入门(安装配置篇)</title>
    <link href="https://architectang.github.io/2019/07/09/tomcat-%E5%85%A5%E9%97%A8(%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87)/"/>
    <id>https://architectang.github.io/2019/07/09/tomcat-入门(安装配置篇)/</id>
    <published>2019-07-09T12:35:17.000Z</published>
    <updated>2019-07-10T11:44:52.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h6 id="tomcat简介"><a href="#tomcat简介" class="headerlink" title="tomcat简介"></a>tomcat简介</h6><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，它早期的名称为catalina，后来由Apache、Sun 和其他一些公司及个人共同开发而成，并更名为Tomcat。Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选，因为Tomcat 技术先进、性能稳定，成为目前比较流行的Web 应用服务器。Tomcat是应用（java）服务器，它只是一个servlet容器，是Apache的扩展，但它是独立运行的。目前最新的版本为Tomcat 8.0.24 Released。</p><p>Tomcat不是一个完整意义上的Jave EE服务器，它甚至都没有提供对哪怕是一个主要Java EE API的实现；但由于遵守apache开源协议，tomcat却又为众多的java应用程序服务器嵌入自己的产品中构建商业的java应用程序服务器，如JBoss和JOnAS。尽管Tomcat对Jave EE API的实现并不完整，然而很企业也在渐渐抛弃使用传统的Java EE技术（如EJB）转而采用一些开源组件来构建复杂的应用。这些开源组件如Structs、Spring和Hibernate，而Tomcat能够对这些组件实现完美的支持。</p><p><a href="http://www.ttlsa.com/tomcat/tomcat-install-and-configure/" target="_blank" rel="noopener">详细请参考-运维生存时间</a></p><h6 id="1、安装环境"><a href="#1、安装环境" class="headerlink" title="1、安装环境:"></a>1、安装环境:</h6><p>Centos 7 tomcat版本: apache-tomcat-8.5.42.tar java版本: java8</p><p><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">官方网站</a></p><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">下载tomcat8</a></p><h6 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h6><p>上传至Linux 服务器</p><p>创建tomcat安装目录</p><pre><code>mkdir /tomcat</code></pre><p>解压tomcat、jdk</p><pre><code>[root@node1 tomcat]# ll总用量 178712-rw-r--r--. 1 root root   9711748 7月   9 10:55 apache-tomcat-8.5.42.tar.gz-rw-r--r--. 1 root root 173281904 7月   9 10:55 jdk-8u51-linux-x64.tar.gz[root@node1 tomcat]# tar xf jdk-8u51-linux-x64.tar.gz [root@node1 tomcat]# tar xf apache-tomcat-8.5.42.tar.gz [root@node1 tomcat]# </code></pre><p><img src="https://i.loli.net/2019/07/09/5d2401ef70aba45222.png" alt="软件列表"></p><h6 id="3、启动脚本配置"><a href="#3、启动脚本配置" class="headerlink" title="3、启动脚本配置"></a>3、启动脚本配置</h6><pre><code>#!/bin/bashsource /etc/sysconfig/i18nexport JAVA_HOME=/tomcat/jdk1.8.0_51export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH   --配置启动javaexport CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jarexport TOMCAT_HOME=/tomcat/apache-tomcat-8.5.42/export PATH=$PATH:$TOMCAT_HOME/bin#export JAVA_OPTS=&quot;$JAVA_OPTS -Xms10000m -Xmx10000m -Xmn4000m -XX:PermSize=256m -XX:MaxPermSize=512m&quot;    -配置程序内存PROG=&quot;tomcat&quot;IP_ADDR=$(/sbin/ifconfig eth0 | grep &quot;inet addr&quot; | awk &apos;{print $2}&apos; | awk -F &quot;:&quot; &apos;{print $2}&apos;)tomcat_start()  ---启动tomcat{        rm -fr /tomcat/apache-tomcat-8.5.42/work/*     ----删除缓存        rm -fr /tomcat/apache-tomcat-8.5.42/temp/*     ----删除临时缓存        echo  $&quot;Starting $IP_ADDR $PROG: &quot;        cd /tomcat/apache-tomcat-8.5.42/bin/        ./startup.sh        echo &quot;tomcat 8 starting......&quot;}tomcat_log()    ---查看程序日志{        echo -n $&quot;ShowLoging $IP_ADDR $PROG log: &quot;        tail -n200 -f /tomcat/apache-tomcat-8.5.42/logs/catalina.out}tomcat_stop()  ---停止tomcat{    echo $&quot;Stopping $IP_ADDR $PROG: &quot;        kill $(ps -ef | grep java | grep -v &quot;grep&quot; | grep &quot;apache-tomcat&quot; |awk -F &apos; &apos; &apos;{print $2}&apos;)        sleep 12        TOMCAT_STATUS1=$(ps -ef | grep java | grep -v &quot;grep&quot;| grep &quot;apache-tomcat&quot;)        if [ -n &quot;$TOMCAT_STATUS1&quot; ];then                echo &quot;Run Kill -9&quot;                kill -9 $(ps -ef | grep java | grep -v &quot;grep&quot; | grep &quot;apache-tomcat&quot; |awk -F &quot; &quot; &apos;{print $2}&apos;)                sleep 2        fi        TOMCAT_STATUS2=$(ps -ef | grep java | grep -v &quot;grep&quot;| grep &quot;apache-tomcat&quot; )        if [ -z &quot;$TOMCAT_STATUS2&quot; ];then                echo &quot;Tomcat Stop ok&quot;        else                exit 1        fi}tomcat_status()   ---查看tomcat程序状态{        ps -ef | grep java | grep -v &quot;grep&quot;| grep &quot;tomcat&quot;}case &quot;$1&quot; instart)        tomcat_start;        ;;stop)        tomcat_stop;        ;;restart)        tomcat_stop;        tomcat_start;        ;;status)                tomcat_status;                ;;log)        tomcat_log;                ;;*)        echo $&quot;Usage: $prog {start | stop | restart | log | status}&quot;        exit 1esac</code></pre><p>tomcat 需要jdk才能运行，上面解压以后我是在tomcat启动脚本里面配置的jdk目录，也可以定义在系统全局变量里面，但是我不会这么做，因为我们的环境经常是运行多个实例且JDK版本要求不同，如果安装多个jdk会造成全局冲突</p><p>全局变量定义方式:</p><pre><code>vim /etc/profile写入以下内容:export JAVA_HOME=/jboss/jdk1.8.0_51export CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/binsource /etc/profile -- 生效配置验证java[root@node1 ~]# java -versionjava version &quot;1.8.0_51&quot;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)[root@node1 ~]# </code></pre><p><img src="https://i.loli.net/2019/07/09/5d2411d062f9884358.png" alt="jdk.png"></p><h6 id="4、启动tomcat"><a href="#4、启动tomcat" class="headerlink" title="4、启动tomcat"></a>4、启动tomcat</h6><pre><code>[root@node1 ~]# ./tomcat.sh start   ---启动服务Starting  tomcat: Using CATALINA_BASE:   /tomcat/apache-tomcat-8.5.42Using CATALINA_HOME:   /tomcat/apache-tomcat-8.5.42Using CATALINA_TMPDIR: /tomcat/apache-tomcat-8.5.42/tempUsing JRE_HOME:        /jboss/jdk1.8.0_51/jreUsing CLASSPATH:       /tomcat/apache-tomcat-8.5.42/bin/bootstrap.jar:/tomcat/apache-tomcat-8.5.42/bin/tomcat-juli.jarTomcat started.tomcat 8 starting......[root@node1 ~]# ./tomcat.sh statusroot     24103     1  0 11:39 ?        00:00:04 /jboss/jdk1.8.0_51/jre/bin/java -Djava.util.logging.config.file=/tomcat/apache-tomcat-8.5.42/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms1000m -Xmx1000m -Xmn400m -XX:PermSize=256m -XX:MaxPermSize=512m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /tomcat/apache-tomcat-8.5.42/bin/bootstrap.jar:/tomcat/apache-tomcat-8.5.42/bin/tomcat-juli.jar -Dcatalina.base=/tomcat/apache-tomcat-8.5.42 -Dcatalina.home=/tomcat/apache-tomcat-8.5.42 -Djava.io.tmpdir=/tomcat/apache-tomcat-8.5.42/temp org.apache.catalina.startup.Bootstrap start    09-Jul-2019 11:39:42.759 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:        Apache Tomcat/8.5.4209-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Jun 4 2019 20:29:04 UTC09-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:         8.5.42.009-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux09-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            3.10.0-327.el7.x86_6409-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd6409-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /jboss/jdk1.8.0_51/jre09-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           1.8.0_51-b1609-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation09-Jul-2019 11:39:42.763 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /tomcat/apache-tomcat-8.5.4209-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /tomcat/apache-tomcat-8.5.4209-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/tomcat/apache-tomcat-8.5.42/conf/logging.properties09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Xms1000m09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Xmx1000m09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Xmn400m09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -XX:PermSize=256m09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -XX:MaxPermSize=512m09-Jul-2019 11:39:42.764 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=204809-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.protocol.handler.pkgs=org.apache.catalina.webresources09-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK=002709-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dignore.endorsed.dirs=09-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/tomcat/apache-tomcat-8.5.4209-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/tomcat/apache-tomcat-8.5.4209-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/tomcat/apache-tomcat-8.5.42/temp09-Jul-2019 11:39:42.765 信息 [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib]09-Jul-2019 11:39:43.048 信息 [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;http-nio-8080&quot;]09-Jul-2019 11:39:43.071 信息 [main] org.apache.tomcat.util.net.NioSelectorPool.getSharedSelector Using a shared selector for servlet write/read09-Jul-2019 11:39:43.095 信息 [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;ajp-nio-8009&quot;]09-Jul-2019 11:39:43.113 信息 [main] org.apache.tomcat.util.net.NioSelectorPool.getSharedSelector Using a shared selector for servlet write/read09-Jul-2019 11:39:43.124 信息 [main] org.apache.catalina.startup.Catalina.load Initialization processed in 1109 ms09-Jul-2019 11:39:43.158 信息 [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]09-Jul-2019 11:39:43.158 信息 [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet Engine: Apache Tomcat/8.5.4209-Jul-2019 11:39:43.207 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/tomcat/apache-tomcat-8.5.42/webapps/ROOT]09-Jul-2019 11:44:19.656 警告 [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [276,003] milliseconds.09-Jul-2019 11:44:19.697 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/tomcat/apache-tomcat-8.5.42/webapps/ROOT] has finished in [276,491] ms09-Jul-2019 11:44:19.697 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/tomcat/apache-tomcat-8.5.42/webapps/docs]09-Jul-2019 11:44:19.739 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/tomcat/apache-tomcat-8.5.42/webapps/docs] has finished in [42] ms09-Jul-2019 11:44:19.739 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/tomcat/apache-tomcat-8.5.42/webapps/examples]09-Jul-2019 11:44:20.212 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/tomcat/apache-tomcat-8.5.42/webapps/examples] has finished in [473] ms09-Jul-2019 11:44:20.213 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/tomcat/apache-tomcat-8.5.42/webapps/host-manager]09-Jul-2019 11:44:20.266 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/tomcat/apache-tomcat-8.5.42/webapps/host-manager] has finished in [53] ms09-Jul-2019 11:44:20.266 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/tomcat/apache-tomcat-8.5.42/webapps/manager]09-Jul-2019 11:44:20.293 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/tomcat/apache-tomcat-8.5.42/webapps/manager] has finished in [27] ms09-Jul-2019 11:44:20.314 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-nio-8080&quot;]09-Jul-2019 11:44:20.342 信息 [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-nio-8009&quot;]09-Jul-2019 11:44:20.344 信息 [main] org.apache.catalina.startup.Catalina.start Server startup in 277219 ms    ----看到此输出，程序就已经正常启动</code></pre><p>通过浏览器访问tomcat服务,tomcat 默认端口号为8080</p><pre><code>http://ipaddr:8080</code></pre><p><img src="https://i.loli.net/2019/07/09/5d240e566144292606.png" alt="tomcat.png"><br>tomcat端口可在/conf/server.xml文件中修改</p><pre><code>67    Define a non-SSL/TLS HTTP/1.1 Connector on port 8080 68    --&gt; 69    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;    --将8080修改为80或其他需要的端口 70               connectionTimeout=&quot;20000&quot; 71               redirectPort=&quot;8443&quot; /&gt; 72    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</code></pre><p><img src="https://i.loli.net/2019/07/09/5d2413ad1c50b94868.png" alt="8080.png"><br>tomcat已安装完毕</p><h6 id="5、tomcat目录结构说明"><a href="#5、tomcat目录结构说明" class="headerlink" title="5、tomcat目录结构说明"></a>5、tomcat目录结构说明</h6><p><img src="https://i.loli.net/2019/07/09/5d240ec19f9ee56826.png" alt="目录结构.png"></p><pre><code>bin             -- 程序启动目录conf            -- 配置文件目录lib                -- 库文件目录logs            -- 日志文件目录temp            -- 临时缓存目录webapps            -- web 应用家目录work            -- 工作缓存目录</code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="Apache" scheme="https://architectang.github.io/categories/Linux/Apache/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="Apache" scheme="https://architectang.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq 入门(集群安装篇)</title>
    <link href="https://architectang.github.io/2019/07/02/Rabbitmq-%E5%85%A5%E9%97%A8(%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E7%AF%87)/"/>
    <id>https://architectang.github.io/2019/07/02/Rabbitmq-入门(集群安装篇)/</id>
    <published>2019-07-02T11:04:05.000Z</published>
    <updated>2019-07-10T11:44:28.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h5><p>RabbitMQ是采用Erlang语言实现AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。<br>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等。<br>RabbitMQ是目前非常热门的一款消息中间件，很多行业都在使用这个消息中间件，RabbitMQ凭借其高可靠、易扩展、高可用及丰富的功能特性收到很多人的青睐。</p><h5 id="一、软件下载："><a href="#一、软件下载：" class="headerlink" title="一、软件下载："></a>一、软件下载：</h5><p>下载<a href="https://pan.baidu.com/s/1QLR4OelHXfMGLYywD13ydw" target="_blank" rel="noopener">Erlang</a> 百度云提取码: 864m</p><p>下载<a href="https://pan.baidu.com/s/15xSC2qo6-0Jh6FYnXkA4Yw" target="_blank" rel="noopener">Rabbitmq 源码包</a> 百度云提取码: qwih</p><p><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">点击此处跳转到官方网站下载最新版本</a></p><h5 id="二、安装环境"><a href="#二、安装环境" class="headerlink" title="二、安装环境:"></a>二、安装环境:</h5><p>node1 172.31.8.8 system Centos 7 —- node3 172.31.8.107 system Centos 7</p><p>node2 172.31.8.13 system Centos 7 —- node4 172.31.8.75 system Centos 7</p><p>软件版本：</p><p>Erlang 21.3</p><p>rabbitmq 3.7.7</p><h5 id="三、单点安装-以下操作需要在其他四个节点重复执行"><a href="#三、单点安装-以下操作需要在其他四个节点重复执行" class="headerlink" title="三、单点安装(以下操作需要在其他四个节点重复执行)"></a>三、单点安装(以下操作需要在其他四个节点重复执行)</h5><p>1、分别编辑四台机器的/etc/hosts 文件，增加以下内容</p><p>172.31.8.8 node1</p><p>172.31.8.13 node2</p><p>172.31.8.107 node3</p><p>172.31.8.75 node4</p><p>2、安装依赖包</p><pre><code>yum install -y *epel* gcc-c++ unixODBC unixODBC-devel openssl-devel ncurses-devel</code></pre><p>3、编译安装 Erlang</p><pre><code>[root@node1 ~]# tar xf otp_src_21.3.tar.gz[root@node1 ~]# cd otp_src_21.3[root@node1 otp_src_21.3]# ./configure --prefix=/usr/local/bin/erlang --without-javac[root@node1 otp_src_21.3]# make &amp;&amp; make install[root@node1 otp_src_21.3]# echo &quot;export PATH=$PATH:/usr/local/bin/erlang/bin:/usr/local/bin/rabbitmq_server-3.6.5/sbin&quot; &gt;&gt; /etc/profile[root@node1 otp_src_21.3]# source /etc/profile</code></pre><p>查看erlang 是否安装成功，出现以下输出即证明erlang已经安装成功<br><img src="https://i.loli.net/2019/07/02/5d1b6526a7b9185754.png" alt="erlang版本.png"></p><p>4、安装Rabbitmq</p><pre><code>[root@node1 ~]# tar xf rabbitmq-server-generic-unix-3.7.7.tar[root@node2 ~]# mv rabbitmq_server-3.7.7 /usr/local/rabbitmq-3.7.7[root@node2 ~]# cd /usr/local/rabbitmq-3.7.7/[root@node1 ~]# echo &quot;export PATH=$PATH:/usr/local/rabbitmq-3.7.7/sbin&quot; &gt;&gt; /etc/profile[root@node1 ~]# source /etc/profile[root@node1 ~]# rabbitmq-plugins enable rabbitmq_management   ---打开管理页面插件[root@node1 ~]# rabbitmq-server -detached  --后台启动服务[root@node1 ~]# rabbitmqctl add_user  admin 123456  --增加用户名admin，密码123456[root@node1 ~]# rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; [root@node1 ~]# rabbitmqctl set_user_tags admin administrator --设置用户admin为管理员</code></pre><p>打开web页面，出现以下页面即安装成功</p><p>node1<br><img src="https://i.loli.net/2019/07/03/5d1ca62e894fb35867.png" alt="rabbitmqnode1.png"><br>node2<br><img src="https://i.loli.net/2019/07/03/5d1ca66bb841381637.png" alt="rabbitmqnode2.png"></p><h5 id="四、部署集群"><a href="#四、部署集群" class="headerlink" title="四、部署集群:"></a>四、部署集群:</h5><p>1、 修改 .erlang.cookie文件，node1、node4节点内容改为一致</p><pre><code>[root@node1 ~]# chmod 400 .erlang.cookie  --设置.erlang.cookie文件权限,为了防止添加集群失败四个节点均需要调整为一致[root@node1 ~]# scp .erlang.cookie root@172.31.8.13:/root/[root@node1 ~]# scp .erlang.cookie root@172.31.8.107:/root/[root@node1 ~]# scp .erlang.cookie root@172.31.8.75:/root/</code></pre><p>添加集群失败报错示例: 出现此信息可根据提示进行排查<br><img src="https://i.loli.net/2019/07/03/5d1cb7afc3b9469683.png" alt="报错示例.png"><br>2、 替换完.erlang.cookie文件，需要重启各个节点的rabbitmq服务</p><pre><code>node1[root@node1 ~]# kill -9 PID[root@node1 ~]# rabbitmq-server -detachednode2[root@node2 ~]# kill -9 PID[root@node2 ~]# rabbitmq-server -detachednode3[root@node3 ~]# kill -9 PID[root@node3 ~]# rabbitmq-server -detachednode4[root@node4 ~]# kill -9 PID[root@node5 ~]# rabbitmq-server -detached</code></pre><p>3、添加节点到集群，将node1节点作为主节点</p><p>在 node2 节点执行以下命令：</p><pre><code>[root@node2 ~]# rabbitmqctl stop_app[root@node4 ~]# rabbitmqctl join_cluster rabbit@node1  --默认为disc节点，如果需要指定节点角色，可以添加--ram/--disc参数[root@node4 ~]# rabbitmqctl start_app[root@node4 ~]# rabbitmqctl cluster_status</code></pre><p>以上命令在node3、4节点重复执行</p><p>执行结果:<br><img src="https://i.loli.net/2019/07/03/5d1cb507de47990688.png" alt="添加集群.png"><br>打开web管理页面查看状态<br><img src="https://i.loli.net/2019/07/03/5d1cb57e207a876254.png" alt="查看集群.png"></p><p>到此Rabbitmq集群已经安装完毕，四个节点均已正常运行</p><h5 id="五、集群管理"><a href="#五、集群管理" class="headerlink" title="五、集群管理"></a>五、集群管理</h5><p>1、假设Rabbitmq-node2节点需要退出集群</p><p>在node2节点执行：</p><pre><code>rabbitmqctl stop_app   --停止rabbitmq服务rabbitmqctl reset --将RabbitMQ node还原到最初状态.包括从所在群集中删除此node,从管理数据库中删除所有配置数据，如已配置的用户和虚拟主机，以及删除所有持久化消息.rabbitmqctl start_app </code></pre><p>在主节点（node1）执行</p><pre><code>rabbitmqctl forget_cluster_node rabbit@node2 --此命令会从集群中删除rabbit@node2节点.</code></pre><p>2、修改node2、node4节点为内存节点，在node2、4节点执行:</p><pre><code>[root@node2 ~]# rabbitmqctl stop_app   --停止rabbitmq服务[root@node2 ~]# rabbitmqctl change_cluster_node_type ram    --修改节点为内存节点[root@node2 ~]# rabbitmqctl start_app    --启动服务[root@node2 ~]# rabbitmqctl cluster_status --查看集群状态</code></pre><p>执行结果可以看到node2节点已经修改为RAM节点，disc节点为node1、3、4<br><img src="https://i.loli.net/2019/07/04/5d1d75112e7ab28091.png" alt="node2RAM.png"><br>再修改node4节点：<br><img src="https://i.loli.net/2019/07/04/5d1d7671ed99316232.png" alt="node4RAM.png"><br>node2、node4节点已经成功修改为内存节点，现在集群就是双内存、双硬盘节点，从控制台查看更为直观:<br><img src="https://i.loli.net/2019/07/04/5d1d79643889841417.png" alt="web控制台.png"></p><p>更多管理命令可参考文档:</p><p><a href="https://blog.csdn.net/wulex/article/details/64127224" target="_blank" rel="noopener">https://blog.csdn.net/wulex/article/details/64127224</a></p><p><a href="https://www.rabbitmq.com/clustering.html" target="_blank" rel="noopener">点击此处查看官方文档</a></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="Rabbitmq" scheme="https://architectang.github.io/categories/Linux/Rabbitmq/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="Rabbitmq" scheme="https://architectang.github.io/tags/Rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>DDOS网络攻击测试工具LOIC</title>
    <link href="https://architectang.github.io/2019/06/10/DDOS%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7LOIC/"/>
    <id>https://architectang.github.io/2019/06/10/DDOS网络攻击测试工具LOIC/</id>
    <published>2019-06-10T13:35:34.000Z</published>
    <updated>2019-07-10T13:56:49.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p><img src="https://i.loli.net/2019/07/10/5d25e9ed4457a89639.jpg" alt="DDOS图片.jpg"></p><h6 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h6><p>DoS(Denial Of Service)攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络<br>无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃。然而随着网络上免费的可用DDOS工具增多，Dos攻击也日益增长，下面介绍<br>一款Hacker常用的Dos攻击工具LOIC（卢卡）</p><h4 id="特别提示-此款工具仅限于教学测试、攻防演练用途，禁止用于非法途径"><a href="#特别提示-此款工具仅限于教学测试、攻防演练用途，禁止用于非法途径" class="headerlink" title="特别提示: 此款工具仅限于教学测试、攻防演练用途，禁止用于非法途径"></a>特别提示: 此款工具仅限于教学测试、攻防演练用途，禁止用于非法途径</h4><p>LOIC（卢卡）（Low Orbit Ion Canon）</p><p>LOTC是一个最受欢迎的DOS攻击工具。 这个工具被去年流行的黑客集团“<a href="https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E8%80%85%E9%BB%91%E5%AE%A2%E7%BB%84%E7%BB%87/8378313?fr=aladdin" target="_blank" rel="noopener">匿名者</a>”用于对许多大公司的网络攻击。</p><p>它可以通过使用单个用户执行DOS攻击小型服务器，工具非常易于使用，即便你是一个初学者。 这个工具执行DOS攻击通过发送UDP,TCP或HTTP请求到受<br>害者服务器。 你只需要知道服务器的IP地址或URL.还有其他类似的工具如：XOIC、HULK等等</p><p><a href="http://sourceforge.net/projects/loic/" target="_blank" rel="noopener">下载地址</a></p><h6 id="2、使用方法"><a href="#2、使用方法" class="headerlink" title="2、使用方法"></a>2、使用方法</h6><p>LOIC 可用于内外网压力测试，下载打开即可直接使用</p><p>LOIC 应用界面:<br><img src="https://i.loli.net/2019/07/10/5d25ed928ec7f93578.png" alt="LOIC.png"></p><h4 id="温馨提示：珍爱生命，远离网络攻击。"><a href="#温馨提示：珍爱生命，远离网络攻击。" class="headerlink" title="温馨提示：珍爱生命，远离网络攻击。"></a>温馨提示：珍爱生命，远离网络攻击。</h4><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络" scheme="https://architectang.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://architectang.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络安全" scheme="https://architectang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="DDOS" scheme="https://architectang.github.io/tags/DDOS/"/>
    
  </entry>
  
  <entry>
    <title>jira(安装篇)</title>
    <link href="https://architectang.github.io/2019/05/21/jira(%E5%AE%89%E8%A3%85%E7%AF%87)/"/>
    <id>https://architectang.github.io/2019/05/21/jira(安装篇)/</id>
    <published>2019-05-21T07:09:04.000Z</published>
    <updated>2019-07-10T11:43:14.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h4 id="一、jira环境需求"><a href="#一、jira环境需求" class="headerlink" title="一、jira环境需求"></a>一、jira环境需求</h4><p>system： Linux</p><p>memory： 2GB</p><p>Mysql数据库</p><p>Jdk jdk-8u92-linux-x64.rpm</p><p>Jira atlassian-jira-6.4.12-x64</p><p>Jira + 数据库连接插件mysql-connector-java-5.1.36-bin</p><p>部署前机器的内存至少为2GB.否则会出现如下错误：</p><p><img src="https://i.loli.net/2019/05/21/5ce3a50c9a7c063889.png" alt="1.png"></p><h4 id="二、安装部署"><a href="#二、安装部署" class="headerlink" title="二、安装部署"></a>二、安装部署</h4><p>部署前配置 关闭iptables和selinux</p><p>service iptables stop &amp;&amp; setenforce 0</p><p><img src="https://i.loli.net/2019/05/21/5ce3a5b347fb286893.png" alt="2.png"></p><p>2.1 jdk安装</p><p><img src="https://i.loli.net/2019/05/21/5ce3a5bd32b9498242.png" alt="3.png"></p><p>查看版本号 jdk安装完毕</p><p><img src="https://i.loli.net/2019/05/21/5ce3a5f64c72b78997.png" alt="4.png"></p><p>2.2 安装mysql数据库（如果有的可以跳过安装这一步）采用的是yum安装</p><p>yum install <a href="http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm" target="_blank" rel="noopener">http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm</a></p><p><img src="https://i.loli.net/2019/05/21/5ce3a62b49dd383541.png" alt="5.png"></p><p>yum install Percona-Server-server-56</p><p><img src="https://i.loli.net/2019/05/21/5ce3a6e6b7f9313899.png" alt="6.png"></p><p>初始化mysql数据库，创建账户并赋予链接权限<br><img src="https://i.loli.net/2019/05/21/5ce3a6e6e8b3e54323.png" alt="7.png"></p><p>创建jira库和jira用户</p><pre><code>create database jiradb character set utf8;grant select,insert,update,delete,create,drop,alter,index on jiradb.* to &apos;jira&apos;@&apos;localhost&apos; identified by &apos;jira&apos;;flush privileges;</code></pre><p><img src="https://i.loli.net/2019/05/21/5ce3a738b461110973.png" alt="8.png"></p><p>退出，使用jira账户进行登陆测试</p><pre><code>mysql –ujira –p</code></pre><p><img src="https://i.loli.net/2019/05/21/5ce3a772f2b4830067.png" alt="9.png"></p><p>下载mysql-connector-java-5.1.39.tar.gz 连接</p><p>2.3 安装jira</p><p>上传jira文件</p><p><img src="https://i.loli.net/2019/05/21/5ce3a7e034ce891378.png" alt="10.png"></p><p>Chmod +x</p><p>./</p><p><img src="https://i.loli.net/2019/05/21/5ce3a830932c224886.png" alt="11.png"></p><p>Jira web访问端口为8080</p><p><img src="https://i.loli.net/2019/05/21/5ce3a85a0ec1b20574.png" alt="12.png"></p><p>由于jira默认是不支持使用mysql数据库的，如果用mysql的话就得把链接插件放到以下目录，并重启jira</p><p>上传mysql – jira 连接插件</p><p>cd /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</p><p><img src="https://i.loli.net/2019/05/21/5ce3a87716ff631694.png" alt="13.png"></p><p>上传文件</p><p>cd /opt/atlassian/jira/atlassian-jira/WEB-INF/lib/</p><p><img src="https://i.loli.net/2019/05/21/5ce3a8aba031e19353.png" alt="14.png"></p><p>上传中文语言包</p><p><img src="https://i.loli.net/2019/05/21/5ce3a8d45564756840.png" alt="15.png"></p><p>删除 cd /var/atlassian/application-data/jira/</p><p><img src="https://i.loli.net/2019/05/21/5ce3a8f8d98a798813.png" alt="16.png"></p><p>打开浏览器，开始设置向导</p><p>连接数据库</p><p><img src="https://i.loli.net/2019/05/21/5ce3a923ded2684231.png" alt="18.png"></p><p>选择模式</p><p><img src="https://i.loli.net/2019/05/21/5ce3a923e9c8d34126.png" alt="17.png"></p><p>装的过程中需要在官网获取试用序列号，然后进行破解！！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="jira" scheme="https://architectang.github.io/categories/Linux/jira/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="jira" scheme="https://architectang.github.io/tags/jira/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 缓存数据清理</title>
    <link href="https://architectang.github.io/2019/05/20/Zabbix-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"/>
    <id>https://architectang.github.io/2019/05/20/Zabbix-缓存数据清理/</id>
    <published>2019-05-20T06:32:24.000Z</published>
    <updated>2019-07-10T14:05:34.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>zabbix监控运行一段时间以后，会留下大量的历史监控数据，zabbix数据库一直在增大；可能会造成系统性能下降，查看历史数据室查询速度缓慢。</p><p>zabbix里面最大的表就是history和history_uint两个表，而且zabbix里面的时间是使用的时间戳方式记录，所以可以根据时间戳来删除历史数据<br><a id="more"></a><br>一、关闭zabbix、http服务</p><pre><code>pkill -9 zabbixservice httpd stop</code></pre><p>二、清理zabbix历史数据</p><p>1、查看数据库目录文件</p><pre><code>[root@zabbix-server zabbix]# cd /var/lib/mysql/zabbix/[root@zabbix-server zabbix]# ls -lh | grep Gtotal 177G-rw-r----- 1 mysql mysql 1.7G Dec 24 13:49 events.ibd-rw-r----- 1 mysql mysql  60G Dec 24 13:49 history.ibd-rw-r----- 1 mysql mysql 2.4G Dec 24 13:49 history_str.ibd-rw-r----- 1 mysql mysql  99G Dec 24 13:49 history_uint.ibd-rw-r----- 1 mysql mysql 4.6G Dec 24 13:02 trends.ibd-rw-r----- 1 mysql mysql 9.5G Dec 24 13:49 trends_uint.ibd[root@zabbix-server zabbix]# </code></pre><p>生成Unix时间戳。时间定为2018年2月1日（暂定是保存18年2月以后的监控数据）</p><pre><code>[root@zabbix-server zabbix]# date +%s -d &quot;Feb 1, 2018 00:00:00&quot;    #执行此命令以后会生成一个ID 1517414400   #这是生成的ID</code></pre><p>2、数据备份</p><pre><code>[root@zabbix-server zabbix]#mysql -uroot -p zabbix &gt; /root/mysqlback/zabbix.sql     #需要创建mysqlback目录</code></pre><p>3、 登录数据库</p><pre><code>[root@zabbix-server zabbix]# mysql -uroot -pEnter password: Welcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 7Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt; use zabbix;    #选择zabbix数据库</code></pre><p>执行sql查看指定日期之前的数据大小：</p><pre><code>SELECT table_schema as `Database`,table_name AS `Table`,round(((data_length + index_length) / 1024 / 1024 / 1024), 2) `Size in MB`FROM information_schema.TABLES where CREATE_TIME &lt; &apos;2018-02-01 00:00:00&apos; and table_name=&apos;history.ibd&apos;;</code></pre><p>根据需要修改日期和查询的表名称(如果查询出来的结果是0.0，需要将sql中的三个1024删除一个，以G为单位显示)</p><p>4、 执行以下命令，清理指定时间之前的数据、对zabbix数据库执行以下sql</p><pre><code>delete from history where clock &lt; 1517414400;optimize table history;delete from history_uint where clock &lt; 1517414400;optimize table history_uint;delete from trends where clock &lt; 1517414400;optimize table trends;delete from trends_uint where clock &lt; 1517414400;optimize table trends_uint;</code></pre><p>注意：sql中的ID是生成Unix时间戳的ID号,需要改为自己生成的ID号<br>三、启动服务</p><pre><code>/usr/sbin/zabbix_server -c /etc/zabbix/zabbix_server.conf    #zabbix server/usr/sbin/zabbix_agentd -c /etc/zabbix/zabbix_agentd.conf    #zabbix agentservice httpd start</code></pre><p>===============================分===========隔==========符===================================</p><p>1、使用truncate命令清空zabbix 所有监控数据</p><pre><code>-------------------------------------------------------truncate table history;optimize table history;------------------------------------------------------- truncate table history_str;optimize table history_str;-------------------------------------------------------truncate table history_uint;optimize table history_uint;-------------------------------------------------------truncate table trends;optimize table trends;-------------------------------------------------------truncate table trends_uint; optimize table trends_uint; -------------------------------------------------------truncate table events;optimize table events;-------------------------------------------------------</code></pre><p>注意：这些命令会把zabbix所有的监控数据清空，操作前注意备份数据库</p><p>truncate是删除了表，然后根据表结构重新建立，delete删除的是记录的数据没有修改表</p><p>truncate执行删除比较快，但是在事务处理安全性方面不如delete,如果我们执行truncat的表正在处理事务，这个命令退出并会产生错误信息</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;zabbix监控运行一段时间以后，会留下大量的历史监控数据，zabbix数据库一直在增大；可能会造成系统性能下降，查看历史数据室查询速度缓慢。&lt;/p&gt;&lt;p&gt;zabbix里面最大的表就是history和history_uint两个表，而且zabbix里面的时间是使用的时间戳方式记录，所以可以根据时间戳来删除历史数据&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="zabbix" scheme="https://architectang.github.io/categories/Linux/zabbix/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="zabbix" scheme="https://architectang.github.io/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Redis 故障恢复</title>
    <link href="https://architectang.github.io/2019/05/10/Redis-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    <id>https://architectang.github.io/2019/05/10/Redis-故障恢复/</id>
    <published>2019-05-10T06:25:37.000Z</published>
    <updated>2019-07-10T14:05:51.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>案例一、<br>ResponseError: MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk.<br><a id="more"></a><br>Commands that may modify the data set are disabled. Please check Redis logs for details about the error.<br>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用。请查看Redis日志的详细错误信息。<br>原因：强制关闭redis快照导致不能持久化</p><p>解决方案：<br>将：stop-writes-on-bgsave-error 设置为 no</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;案例一、&lt;br&gt;ResponseError: MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk.&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="redis" scheme="https://architectang.github.io/categories/Linux/redis/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="redis" scheme="https://architectang.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Python统计nginx日志前十个IP的访问量，并以柱状图显示</title>
    <link href="https://architectang.github.io/2018/12/28/%E4%BD%BF%E7%94%A8Python%E7%BB%9F%E8%AE%A1nginx%E6%97%A5%E5%BF%97%E5%89%8D%E5%8D%81%E4%B8%AAIP%E7%9A%84%E8%AE%BF%E9%97%AE%E9%87%8F%EF%BC%8C%E5%B9%B6%E4%BB%A5%E6%9F%B1%E7%8A%B6%E5%9B%BE%E6%98%BE%E7%A4%BA/"/>
    <id>https://architectang.github.io/2018/12/28/使用Python统计nginx日志前十个IP的访问量，并以柱状图显示/</id>
    <published>2018-12-28T15:48:31.000Z</published>
    <updated>2019-07-10T16:06:18.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h6 id="1、脚本代码"><a href="#1、脚本代码" class="headerlink" title="1、脚本代码"></a>1、脚本代码</h6><p><a href="https://www.cnblogs.com/ArchitecTang/p/10189811.html" target="_blank" rel="noopener">可参考本人博客园文章</a></p><pre><code>import matplotlib.pyplot as pltnginx_file = &apos;&apos;  --填写nginx日志文件名，需在同一目录ip = {}#筛选nginx日志文件中的IPwith open(nginx_file) as f:    for i in f.readlines():        s = i.strip().split()[0]        lengh = len(ip.keys())        #统计每个IP的访问以字典存储        if s in ip.keys():            ip[s] = ip[s] + 1        else:            ip[s] = 1#以IP出现的次数排序返回对象为listip = sorted(ip.items(), key=lambda e:e[1], reverse=True)#取列表前十newip = ip[0:20:1]tu = dict(newip)x = []y = []for k in tu:    x.append(k)    y.append(tu[k])plt.title(&apos;ip access&apos;)plt.xlabel(&apos;ip address&apos;)plt.ylabel(&apos;pv&apos;)#X 轴项的翻转角度plt.xticks(rotation=70)#显示每个柱状图的值for a,b in zip(x,y):    plt.text(a, b, &apos;%.0f&apos; % b, ha=&apos;center&apos;, va= &apos;bottom&apos;,fontsize=7)plt.bar(x,y)plt.legend()plt.show()</code></pre><h6 id="2、效果图"><a href="#2、效果图" class="headerlink" title="2、效果图:"></a>2、效果图:</h6><p><img src="https://i.loli.net/2019/07/10/5d260b4e522ce72252.png" alt="nginx柱状图.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://architectang.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://architectang.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PTES渗透测试执行标准</title>
    <link href="https://architectang.github.io/2018/09/17/PTES%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/"/>
    <id>https://architectang.github.io/2018/09/17/PTES渗透测试执行标准/</id>
    <published>2018-09-17T02:57:50.000Z</published>
    <updated>2019-07-10T14:05:12.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="渗透测试注意事项："><a href="#渗透测试注意事项：" class="headerlink" title="渗透测试注意事项："></a>渗透测试注意事项：</h5><p>1、不要进行恶意攻击</p><p>2、不要做傻事</p><p>3、在没有获得书面授权时，不要攻击任何目标</p><p>4、考虑清楚攻击将会带来的后果</p><p>4、如果干了非法的事情，记得天网恢恢疏而不漏</p><p><a href="http://www.pentest-standard.org/" target="_blank" rel="noopener">参考官方对于渗透测试执行标准描述（PTES）</a></p><a id="more"></a><p><img src="https://www.aqniu.com/wp-content/uploads/2017/09/Tips-to-Use-Penetration-Testing-App-Developer-Magazine_c80f71bi.jpg" alt></p><h5 id="一：前期交互阶段"><a href="#一：前期交互阶段" class="headerlink" title="一：前期交互阶段"></a>一：前期交互阶段</h5><p>在前期交互阶段，渗透测试团队与客户组织进行交互讨论，最重要的是确定渗透测试的范围、目标、限制条件以及合同细节</p><p>该阶段通常涉及收集客户需求，准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动</p><h5 id="二：情报收集阶段"><a href="#二：情报收集阶段" class="headerlink" title="二：情报收集阶段"></a>二：情报收集阶段</h5><p>在目标范围确定之后，将进入情报搜集（Information Gathering）阶段，渗透团队可以利用各种信息来源与搜集技术方法，尝试更多关于组织网络拓扑、系统配置与安全防御措施的信息。</p><p>渗透测试者可以使用情报搜集方法包括公开来源信息查询、google Hacking 、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。而对目标系统的情报探查能力是渗透者一项非常重要的技能，情报搜集是否充分在很大程度上决定了渗透测的成败，因为如果你遗漏关键的情报信息，你将可能在后面的阶段一无所获。</p><h5 id="三：威胁建模阶段"><a href="#三：威胁建模阶段" class="headerlink" title="三：威胁建模阶段"></a>三：威胁建模阶段</h5><p>在搜集到充分的情报信息之后，渗透测试团队的成员们停下敲击键盘，大家聚到一起针对获取的信息进行威胁建模（Threat Modeling）与攻击规划。这是渗透测试过程中非常重要，但很容易被忽视的一个关键点。<br>通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道。<br>四：漏洞分析阶段<br>在确定出最可行的攻击通道之后，接下来需要考虑该如何取得目标系统的访问控制权，即漏洞分析（Vulnerability Analysis）阶段。<br>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。在该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h5 id="五：渗透攻击阶段"><a href="#五：渗透攻击阶段" class="headerlink" title="五：渗透攻击阶段"></a>五：渗透攻击阶段</h5><p>渗透攻击（Exploitation）是渗透测试过程中最具有魅力的环节。在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现</p><h5 id="六：后渗透攻击阶段"><a href="#六：后渗透攻击阶段" class="headerlink" title="六：后渗透攻击阶段"></a>六：后渗透攻击阶段</h5><p>后渗透攻击（Post Exploitation）是整个渗透测试过程中最能够体现渗透测试团队创造力与技术能力的环节。前面的环节可以说都是在按部就班地完成非常普遍的目标，而在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。<br>在不同的渗透测试场景中，这些攻击目标与途径可能是千变万化的，而设置是否准确并且可行，也取决于团队自身的创新意识、知识范畴、实际经验和技术能力。</p><h5 id="七：报告阶段"><a href="#七：报告阶段" class="headerlink" title="七：报告阶段"></a>七：报告阶段</h5><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告（Reporting）。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><h5 id="八：渗透术语："><a href="#八：渗透术语：" class="headerlink" title="八：渗透术语："></a>八：渗透术语：</h5><p>渗透攻击（Exploit）</p><p>攻击者利用安全漏洞，所进行的攻击行为，常见的渗透攻击技术包括缓冲区溢出、web应用程序漏洞攻击（SQL注入）、利用配置错误等</p><p>攻击载荷（Payload）</p><p>目标系统在被渗透攻击之后执行的代码</p><p>Shellcode</p><p>在渗透攻击时作为攻击载荷运行的一组机器指令，通常用汇编语言编写</p><p>模块（Module）</p><p>一段软件代码组件</p><p>监听器（Listener）</p><p>用来等待连入网络链接的组件</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --&gt;&lt;h5 id=&quot;渗透测试注意事项：&quot;&gt;&lt;a href=&quot;#渗透测试注意事项：&quot; class=&quot;headerlink&quot; title=&quot;渗透测试注意事项：&quot;&gt;&lt;/a&gt;渗透测试注意事项：&lt;/h5&gt;&lt;p&gt;1、不要进行恶意攻击&lt;/p&gt;&lt;p&gt;2、不要做傻事&lt;/p&gt;&lt;p&gt;3、在没有获得书面授权时，不要攻击任何目标&lt;/p&gt;&lt;p&gt;4、考虑清楚攻击将会带来的后果&lt;/p&gt;&lt;p&gt;4、如果干了非法的事情，记得天网恢恢疏而不漏&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.pentest-standard.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考官方对于渗透测试执行标准描述（PTES）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="https://architectang.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="渗透测试" scheme="https://architectang.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息安全" scheme="https://architectang.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="渗透测试" scheme="https://architectang.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>(二)、Ansible在使用过程中出现的错误解决方法</title>
    <link href="https://architectang.github.io/2018/09/02/%E4%BA%8C-%E3%80%81Ansible%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://architectang.github.io/2018/09/02/二-、Ansible在使用过程中出现的错误解决方法/</id>
    <published>2018-09-02T04:47:00.000Z</published>
    <updated>2019-05-16T11:56:43.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h4 id="1-安装完成后允许命令出错"><a href="#1-安装完成后允许命令出错" class="headerlink" title="1.安装完成后允许命令出错"></a>1.安装完成后允许命令出错</h4><pre><code>Traceback (most recent call last):File &quot;/usr/bin/ansible&quot;, line 197, in &lt;module&gt;        (runner, results) = cli.run(options, args)File &quot;/usr/bin/ansible&quot;, line 163, in run        extra_vars=extra_vars,File &quot;/usr/lib/python2.6/site-packages/ansible/runner/__init__.py&quot;, line 233, in __init__        cmd = subprocess.Popen([&apos;ssh&apos;,&apos;-o&apos;,&apos;ControlPersist&apos;], stdout=subprocess.PIPE, stderr=subprocess.PIPE)File &quot;/usr/lib64/python2.6/subprocess.py&quot;, line 639, in __init__        errread, errwrite)File &quot;/usr/lib64/python2.6/subprocess.py&quot;, line 1228, in _execute_child        raise child_exceptionOSError: [Errno 2] No such file or directory</code></pre><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>yum -y install openssh-clients</p><h4 id="2-出现Error-ansible-requires-a-json-module-none-found"><a href="#2-出现Error-ansible-requires-a-json-module-none-found" class="headerlink" title="2.出现Error: ansible requires a json module, none found!"></a>2.出现Error: ansible requires a json module, none found!</h4><pre><code>SSH password:10.0.1.110 | FAILED &gt;&gt; {&quot;failed&quot;: true,&quot;msg&quot;: &quot;Error: ansible requires a json module, nonefound!&quot;,&quot;parsed&quot;: false}</code></pre><h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>python版本过低，可以升级python或者python-simplejson</p><h4 id="3-安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）"><a href="#3-安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）" class="headerlink" title="3.安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）"></a>3.安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）</h4><pre><code>FAILED =&gt; Using a SSH password insteadof a key is not possible because Host Key checking is enabled and sshpass doesnot support this.  Please add this host&apos;sfingerprint to your known_hosts file to manage this host.</code></pre><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>在ansible 服务器上使用ssh 登陆下/etc/ansible/hosts 里面配置的服务器。然后再次使用ansible 去管理就不会报上面的错误了！<br>但这样大批量登陆就麻烦来。因为默认ansible是使用key验证的，如果使用密码登陆的服务器，使用ansible的话，要不修改ansible.cfg配置文件<br>的ask_pass = True给取消注释，要不就在运行命令时候加上-k，这个意思是-k, –ask-pass ask for SSH password。再修改：</p><p>host_key_checking= False即可</p><h4 id="4-如果客户端不在know-hosts里将会报错"><a href="#4-如果客户端不在know-hosts里将会报错" class="headerlink" title="4.如果客户端不在know_hosts里将会报错"></a>4.如果客户端不在know_hosts里将会报错</h4><pre><code>paramiko: The authenticity of host &apos;192.168.24.15&apos;can&apos;t be established.The ssh-rsa key fingerprint is397c139fd4b0d763fcffaee346a4bf6b.Are you sure you want to continueconnecting (yes/no)?</code></pre><h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><p>需要修改ansible.cfg的#host_key_checking= False取消注释</p><h3 id="5-出现FAILED-gt-FAILED-not-a-valid-DSA-private-key-file"><a href="#5-出现FAILED-gt-FAILED-not-a-valid-DSA-private-key-file" class="headerlink" title="5.出现FAILED =&gt; FAILED: not a valid DSA private key file"></a>5.出现FAILED =&gt; FAILED: not a valid DSA private key file</h3><h5 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h5><p>需要你在最后命令内添加参数-k</p><h4 id="6-openssh升级后无法登录报错"><a href="#6-openssh升级后无法登录报错" class="headerlink" title="6.openssh升级后无法登录报错"></a>6.openssh升级后无法登录报错</h4><pre><code>PAM unable todlopen(/lib64/security/pam_stack.so): /lib64/security/pam_stack.so: cannot openshared objectfile: No such file or directory</code></pre><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>sshrpm 升级后会修改/etc/pam.d/sshd 文件。需要升级前备份此文件最后还原即可登录。</p><h4 id="7-第一次系统初始化运行生成本机ansible用户key时报错"><a href="#7-第一次系统初始化运行生成本机ansible用户key时报错" class="headerlink" title="7.第一次系统初始化运行生成本机ansible用户key时报错"></a>7.第一次系统初始化运行生成本机ansible用户key时报错</h4><pre><code>failed: [127.0.0.1] =&gt;{&quot;checksum&quot;: &quot;f5f2f20fc0774be961fffb951a50023e31abe920&quot;,&quot;failed&quot;: true}msg: Aborting, target uses selinux but pythonbindings (libselinux-python) aren&apos;t installed!FATAL: all hosts have already failed –aborting</code></pre><h5 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h5><p>yum -y install libselinux-python</p><p>参考: <a href="http://blog.csdn.net/longxibendi/article/details/46989735" target="_blank" rel="noopener">http://blog.csdn.net/longxibendi/article/details/46989735</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="自动化" scheme="https://architectang.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="自动化" scheme="https://architectang.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Ansible</title>
    <link href="https://architectang.github.io/2018/09/01/Ansible/"/>
    <id>https://architectang.github.io/2018/09/01/Ansible/</id>
    <published>2018-09-01T09:26:09.000Z</published>
    <updated>2019-05-17T06:29:45.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>1、ansible介绍：</p><p>Ansible是一款基于Python开发的自动化运维工具，主要是实现批量系统配置、批量程序部署、批量运行命令、批量执行任务等等诸多功能。</p><p>Ansible是一款灵活的开源工具，能够很大程度简化运维中的配置管理与流程控制方式，它利用推送方式对客户系统加以配置，这样所有工作都可在主服务器端完成。<br>Asible是基于模块工作的，其本身没有批量部署的能力，Ansible<del>~</del>一款运维自动化的软件！<br><a id="more"></a><br>1.1特性</p><p>(1)、no agents：不需要在被管控主机上安装任何客户端；</p><p>(2)、no server：无服务器端，使用时直接运行命令即可；</p><p>(3)、modules in any languages：基于模块工作，可使用任意语言开发模块；</p><p>(4)、yaml，not code：使用yaml语言定制剧本playbook；</p><p>(5)、ssh by default：基于SSH工作；</p><p>(6)、strong multi-tier solution：可实现多级指挥。</p><p><img src="/upload/201809/工作特性.jpg" alt="工作特性"></p><p>1.1 优点</p><p>(1)、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</p><p>(2)、批量任务执行可以写成脚本，而且不用分发到远程就可以执行；</p><p>(3)、使用python编写，维护更简单，ruby语法过于复杂；</p><p>(4)、支持sudo。</p><p><img src="/upload/201809/工作机制.png" alt="工作机制"></p><p>2、ansible安装</p><p>安装epel 源：<br>rpm -ivh <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm" target="_blank" rel="noopener">https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</a></p><p>安装ansible ：<br>yum install ansible -y</p><p>ssh-keygen 生成秘钥文件,如果不想输入密码可以一直回车</p><p>ssh-keygen -t rsa</p><p>cd /root/.ssh/ &amp;&amp; ll ./*</p><p>配置ansible 的hosts 文件：</p><p>vim /etc/ansible/hosts</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;1、ansible介绍：&lt;/p&gt;&lt;p&gt;Ansible是一款基于Python开发的自动化运维工具，主要是实现批量系统配置、批量程序部署、批量运行命令、批量执行任务等等诸多功能。&lt;/p&gt;&lt;p&gt;Ansible是一款灵活的开源工具，能够很大程度简化运维中的配置管理与流程控制方式，它利用推送方式对客户系统加以配置，这样所有工作都可在主服务器端完成。&lt;br&gt;Asible是基于模块工作的，其本身没有批量部署的能力，Ansible&lt;del&gt;~&lt;/del&gt;一款运维自动化的软件！&lt;br&gt;
    
    </summary>
    
      <category term="自动化" scheme="https://architectang.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="自动化" scheme="https://architectang.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>solr6+tomcat8+zookeeper 环境部署</title>
    <link href="https://architectang.github.io/2018/08/22/solr6+tomcat8+zookeeper%20%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://architectang.github.io/2018/08/22/solr6+tomcat8+zookeeper 环境部署/</id>
    <published>2018-08-22T01:20:50.000Z</published>
    <updated>2019-07-14T18:40:58.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>安装概述：</p><p>以下是部署环境：</p><p>系统环境为：</p><p>三台系统为Centos 6.8 的服务器</p><p>主机IP：10.6.11.19 10.6.11.23 10.6.11.22</p><p>软件环境为：</p><p>tomcat 8.5.24</p><p>jdk1.8.0_162</p><p>solr6.6.3</p><p>zookeepr-3.4.10</p><p>tomcat安装不多说，配置java环境即可启动，出现以下画面就说明tomcat服务已经部署完成</p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328195223983-641651017.png" alt></p><p>将solr6部署到tomcat 8 容器内（仅以单节点安装为例，三个节点的安装步骤是一样的）</p><pre><code>cp -r /home/tomcat/software/solr-6.6.3/server/solr-webapp/webapp /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solrcp -r /home/tomcat/software/solr-6.6.3/server/lib/metrics* /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/lib/rm -f /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/lib/metrics-jetty9-3.2.2.jarcp -r /home/tomcat/software/solr-6.6.3/server/lib/ext/* /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/lib/cp -r /home/tomcat/software/solr-6.6.3/dist/solr-dataimporthandler-* /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/libcp -r /home/tomcat/software/solr-6.6.3/dist/solr-clustering-6.6.3.jar /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/libmkdir /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/classescp -r /home/tomcat/software/solr-6.6.3/server/resources/log4j.properties /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/classes</code></pre><p>创建solrhome目录</p><p>mkdir /home/tomcat/apache-tomcat-8.5.24-solr/solrhome</p><p>cp -r /home/tomcat/software/solr-6.6.3/server/solr/* /home/tomcat/apache-tomcat-8.5.24-solr/solrhome/</p><p>修改web.xml文件，配置solrhome目录和solr访问权限</p><p>vim /home/tomcat/apache-tomcat-8.5.24-solr/webapps/solr/WEB-INF/web.xml</p><p>找到solr/home 根据自己的实际情况配置solr路径</p><pre><code>&lt;env-entry&gt;&lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;&lt;env-entry-value&gt;/home/tomcat/apache-tomcat-8.5.24-solr/solrhome&lt;/env-entry-value&gt;&lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;</code></pre><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328205305280-636337399.png" alt></p><p>配置访问权限，注释下图红圈部分内容</p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328205537011-610781005.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328205630839-1475446582.png" alt></p><p>修改tomcat server.xml文件，配置服务访问端口</p><p>vim /home/tomcat/apache-tomcat-8.5.24-solr/conf/server.xml</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;            maxHttpHeaderSize=&quot;8192&quot;            connectionTimeout=&quot;20000&quot;            maxThreads=&quot;150&quot;            maxSpareThreads=&quot;75&quot;            redirectPort=&quot;8443&quot; /&gt;    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</code></pre><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328205753674-2093690073.png" alt></p><p>修改solr配置文件 host设置为本机IP，port设置和tomcat端口一致，均为8080</p><p>vim /home/tomcat/apache-tomcat-8.5.24-solr/solrhome/solr.xml</p><pre><code>&lt;solr&gt;    &lt;solrcloud&gt;        &lt;str name=&quot;host&quot;&gt;${host:10.6.11.19}&lt;/str&gt;        &lt;int name=&quot;hostPort&quot;&gt;${jetty.port:8080}&lt;/int&gt;        &lt;str name=&quot;hostContext&quot;&gt;${hostContext:solr}&lt;/str&gt;        &lt;bool name=&quot;genericCoreNodeNames&quot;&gt;${genericCoreNodeNames:true}&lt;/bool&gt;        &lt;int name=&quot;zkClientTimeout&quot;&gt;${zkClientTimeout:30000}&lt;/int&gt;        &lt;int name=&quot;distribUpdateSoTimeout&quot;&gt;${distribUpdateSoTimeout:600000}&lt;/int&gt;        &lt;int name=&quot;distribUpdateConnTimeout&quot;&gt;${distribUpdateConnTimeout:60000}&lt;/int&gt;        &lt;str name=&quot;zkCredentialsProvider&quot;&gt;${zkCredentialsProvider:org.apache.solr.common.cloud.DefaultZkCredentialsProvider}&lt;/str&gt;        &lt;str name=&quot;zkACLProvider&quot;&gt;${zkACLProvider:org.apache.solr.common.cloud.DefaultZkACLProvider}&lt;/str&gt;    &lt;/solrcloud&gt;    &lt;shardHandlerFactory name=&quot;shardHandlerFactory&quot;        class=&quot;HttpShardHandlerFactory&quot;&gt;        &lt;int name=&quot;socketTimeout&quot;&gt;${socketTimeout:600000}&lt;/int&gt;        &lt;int name=&quot;connTimeout&quot;&gt;${connTimeout:60000}&lt;/int&gt;    &lt;/shardHandlerFactory&gt;    &lt;/solr&gt;</code></pre><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328210119163-1720093871.png" alt></p><p>重启tomcat 服务，验证安装</p><p>访问地址：<a href="http://IP:8080/solr/#/" target="_blank" rel="noopener">http://IP:8080/solr/#/</a></p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328210304797-69359330.png" alt></p><p>出现以上页面，solr就已成功部署到tomcat容器内创建</p><p>根据需求创建分片,使用以下命令进行创建：</p><pre><code>http://IP:8080/solr/admin/collections?action=CREATE&amp;name=分片名称&amp;numShards=分片数&amp;replicationFactor=副本数&amp;maxShardsPerNode=节点数&amp;collection.configName=conf目录名称</code></pre><p>例如：</p><pre><code>http://10.6.11.19:8080/solr/admin/collections?action=CREATE&amp;name=user&amp;numShards=2&amp;replicationFactor=3&amp;maxShardsPerNode=3&amp;collection.configName=user</code></pre><p>出现以下参数即说明分片创建成功</p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328211655638-132166093.png" alt></p><p>访问<a href="http://IP:8080/solr/#/~cloud" target="_blank" rel="noopener">http://IP:8080/solr/#/~cloud</a> 验证分片</p><p><img src="https://img2018.cnblogs.com/blog/1571891/201903/1571891-20190328211547176-697804153.png" alt><br>使用此命令创建了两个分片，三个副本<br>一般只可以创建两个副本，增加&amp;maxShardsPerNode=3&amp;collection.configName=user 参数突破副本创建限制</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="搜索" scheme="https://architectang.github.io/categories/Linux/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="solr" scheme="https://architectang.github.io/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统安全检查（shell）</title>
    <link href="https://architectang.github.io/2018/04/22/Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%EF%BC%88shell%EF%BC%89/"/>
    <id>https://architectang.github.io/2018/04/22/Linux 系统安全检查（shell）/</id>
    <published>2018-04-22T01:14:09.000Z</published>
    <updated>2019-07-10T13:20:31.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>脚本内容:</p><pre><code>#!/bin/bashecho &quot;         (__)&quot;echo &quot;         (oo)&quot;echo &quot;   /------\/ &quot;echo &quot;  / |    ||  &quot;echo &quot; *  /\---/\  &quot;echo &quot;   ~~   ~~   &quot;echo &quot;Are You Ready?&quot;read keyecho &quot;警告：本脚本只作为日常巡检使用，不会对服务器做任何修改，管理员可以根据此报告进行相应的设置。&quot;echo ------------------------------------------------------------------------echo &quot;查看系统时间&quot;DATE=`date`echo &quot;Date is $DATE&quot;echo ------------------------------------------------------------------------echo &quot;进行系统时间同步&quot;ntpdate time.nist.govecho ------------------------开始进行检查----------------------echo &quot;检查时间为&quot;DATE=`date`echo &quot;Date is $DATE&quot;echo ------------------------主机基本信息检查-----------------------echo &quot;系统版本（Centos或Rehead）&quot;cat /etc/redhat-releaseecho --------------------------------------------------------------------------echo &quot;系统位数（32位或64位）&quot;getconf LONG_BITecho -------------------------检查IP信息-----------------------------------------echo &quot;本机的ip地址是：&quot;ifconfig | grep --color &quot;\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}&quot;echo -------------------------检查系统用户信息---------------------------------------awk -F&quot;:&quot; &apos;{if($2!~/^!|^*/){print &quot;(&quot;$1&quot;)&quot; &quot; 是一个未被锁定的账户，请管理员检查是否需要锁定它或者删除它。&quot;}}&apos; /etc/shadowecho --------------------------------------------------------------------------more /etc/login.defs | grep -E &quot;PASS_MAX_DAYS&quot; | grep -v &quot;#&quot; |awk -F&apos; &apos;  &apos;{if($2!=90){print &quot;/etc/login.defs里面的&quot;$1 &quot;设置的是&quot;$2&quot;天，请管理员改成90天。&quot;}}&apos;echo --------------------------------------------------------------------------more /etc/login.defs | grep -E &quot;PASS_MIN_LEN&quot; | grep -v &quot;#&quot; |awk -F&apos; &apos;  &apos;{if($2!=6){print &quot;/etc/login.defs里面的&quot;$1 &quot;设置的是&quot;$2&quot;个字符，请管理员改成6个字符。&quot;}}&apos;echo --------------------------------------------------------------------------more /etc/login.defs | grep -E &quot;PASS_WARN_AGE&quot; | grep -v &quot;#&quot; |awk -F&apos; &apos;  &apos;{if($2!=10){print &quot;/etc/login.defs里面的&quot;$1 &quot;设置的是&quot;$2&quot;天，请管理员将口令到期警告天数改成10天。&quot;}}&apos;echo --------------------------------------------------------------------------grep TMOUT /etc/profile /etc/bashrc &gt; /dev/null|| echo &quot;未设置登录超时限制，请设置之，设置方法：在/etc/profile或者/etc/bashrc里面添加TMOUT=600参数&quot;echo ------------------------检查服务运行情况-----------------------------------if ps -elf |grep xinet |grep -v &quot;grep xinet&quot;;thenecho &quot;xinetd 服务正在运行，请检查是否可以把xinnetd服务关闭&quot;elseecho &quot;xinetd 服务未开启&quot;fiecho --------------------------------------------------------------------------echo &quot;查看系统密码文件修改时间&quot;ls -ltr /etc/passwdecho --------------------------------------------------------------------------echo  &quot;查看是否开启了ssh服务&quot;if service sshd status | grep -E &quot;listening on|active \(running\)&quot;; thenecho &quot;SSH服务已开启&quot;elseecho &quot;SSH服务未开启&quot;fiecho --------------------------------------------------------------------------echo &quot;查看是否开启了TELNET服务&quot;if more /etc/xinetd.d/telnetd 2&gt;&amp;1|grep -E &quot;disable=no&quot;; thenecho  &quot;TELNET服务已开启 &quot;elseecho  &quot;TELNET服务未开启 &quot;fiecho --------------------------------------------------------------------------echo  &quot;查看系统SSH远程访问设置策略(host.deny拒绝列表)&quot;if more /etc/hosts.deny | grep -E &quot;sshd: &quot;;more /etc/hosts.deny | grep -E &quot;sshd&quot;; thenecho  &quot;远程访问策略已设置 &quot;elseecho  &quot;远程访问策略未设置 &quot;fiecho --------------------------------------------------------------------------echo  &quot;查看系统SSH远程访问设置策略(hosts.allow允许列表)&quot;if more /etc/hosts.allow | grep -E &quot;sshd: &quot;;more /etc/hosts.allow | grep -E &quot;sshd&quot;; thenecho  &quot;远程访问策略已设置 &quot;elseecho  &quot;远程访问策略未设置 &quot;fiecho &quot;当hosts.allow和 host.deny相冲突时，以hosts.allow设置为准。&quot;echo -------------------------------------------------------------------------echo &quot;查看shell是否设置超时锁定策略&quot;if more /etc/profile | grep -E &quot;TIMEOUT= &quot;; thenecho  &quot;系统设置了超时锁定策略 &quot;elseecho  &quot;未设置超时锁定策略 &quot;fiecho -------------------------------------------------------------------------echo &quot;查看syslog日志审计服务是否开启&quot;if service syslog status | egrep &quot; active \(running&quot;;thenecho &quot;syslog服务已开启&quot;elseecho &quot;syslog服务未开启，建议通过service syslog start开启日志审计功能&quot;fiecho -------------------------------------------------------------------------echo &quot;查看syslog日志是否开启外发&quot;if more /etc/rsyslog.conf | egrep &quot;@...\.|@..\.|@.\.|\*.\* @...\.|\*\.\* @..\.|\*\.\* @.\.&quot;;thenecho &quot;客户端syslog日志已开启外发&quot;elseecho &quot;客户端syslog日志未开启外发&quot;fiecho -------------------------------------------------------------------------echo &quot;查看passwd文件中有哪些特权用户&quot;awk -F: &apos;$3==0 {print $1}&apos; /etc/passwdecho ------------------------------------------------------------------------echo &quot;查看系统中是否存在空口令账户&quot;awk -F: &apos;($2==&quot;!!&quot;) {print $1}&apos; /etc/shadowecho &quot;该结果不适用于Ubuntu系统&quot;echo ------------------------------------------------------------------------echo &quot;查看系统中root用户外连情况&quot;lsof -u root |egrep &quot;ESTABLISHED|SYN_SENT|LISTENING&quot;echo ----------------------------状态解释------------------------------echo &quot;ESTABLISHED的意思是建立连接。表示两台机器正在通信。&quot;echo &quot;LISTENING的&quot;echo &quot;SYN_SENT状态表示请求连接&quot;echo ------------------------------------------------------------------------echo &quot;查看系统中root用户TCP连接情况&quot;lsof -u root |egrep &quot;TCP&quot;echo ------------------------------------------------------------------------echo &quot;查看系统中存在哪些非系统默认用户&quot;echo &quot;root:x:“该值大于500为新创建用户，小于或等于500为系统初始用户”&quot;more /etc/passwd |awk -F &quot;:&quot; &apos;{if($3&gt;500){print &quot;/etc/passwd里面的&quot;$1 &quot;的值为&quot;$3&quot;，请管理员确认该账户是否正常。&quot;}}&apos;echo ------------------------------------------------------------------------echo &quot;检查系统守护进程&quot;more /etc/xinetd.d/rsync | grep -v &quot;^#&quot;echo ------------------------------------------------------------------------echo &quot;检查系统是否存在入侵行为&quot;more /var/log/secure |grep refusedecho ------------------------------------------------------------------------echo &quot;-----------------------检查系统是否存在PHP脚本后门---------------------&quot;if find / -type f -name *.php | xargs egrep -l &quot;mysql_query\($query, $dbconn\)|专用网马|udf.dll|class PHPzip\{|ZIP压缩程序 荒野无灯修改版|$writabledb|AnonymousUserName|eval\(|Root_CSS\(\)|黑狼PHP木马|eval\(gzuncompress\(base64_decode|if\(empty\($_SESSION|$shellname|$work_dir |PHP木马|Array\(&quot;$filename&quot;| eval\($_POST\[|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门&quot; |sort -n|uniq -c |sort -rn 1&gt;/dev/null 2&gt;&amp;1;thenecho &quot;检测到PHP脚本后门&quot;find / -type f -name *.php | xargs egrep -l &quot;mysql_query\($query, $dbconn\)|专用网马|udf.dll|class PHPzip\{|ZIP压缩程序 荒野无灯修改版|$writabledb|AnonymousUserName|eval\(|Root_CSS\(\)|黑狼PHP木马|eval\(gzuncompress\(base64_decode|if\(empty\($_SESSION|$shellname|$work_dir |PHP木马|Array\(&quot;$filename&quot;| eval\($_POST\[|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门&quot; |sort -n|uniq -c |sort -rnfind / -type f -name *.php | xargs egrep -l &quot;mysql_query\($query, $dbconn\)|专用网马|udf.dll|class PHPzip\{|ZIP压缩程序 荒野无灯修改版|$writabledb|AnonymousUserName|eval\(|Root_CSS\(\)|黑狼PHP木马|eval\(gzuncompress\(base64_decode|if\(empty\($_SESSION|$shellname|$work_dir |PHP木马|Array\(&quot;$filename&quot;| eval\($_POST\[|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门&quot; |sort -n|uniq -c |sort -rn |awk &apos;{print $2}&apos; | xargs -I{} cp {} /tmp/echo &quot;后门样本已拷贝到/tmp/目录&quot;elseecho &quot;未检测到PHP脚本后门&quot;fiecho ------------------------------------------------------------------------echo &quot;-----------------------检查系统是否存在JSP脚本后门---------------------&quot;find / -type f -name *.jsp | xargs egrep -l &quot;InputStreamReader\(this.is\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门&quot; |sort -n|uniq -c |sort -rn 2&gt;&amp;1find / -type f -name *.jsp | xargs egrep -l &quot;InputStreamReader\(this.is\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门&quot; |sort -n|uniq -c |sort -rn| awk &apos;{print $2}&apos; | xargs -I{} cp {} /tmp/  2&gt;&amp;1 echo ------------------------------------------------------------------------echo &quot;----------------------检查系统是否存在HTML恶意代码---------------------&quot;if find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330&quot; 1&gt;/dev/null 2&gt;&amp;1;thenecho &quot;发现HTML恶意代码&quot;find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330&quot; |sort -n|uniq -c |sort -rnfind / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330&quot; |sort -n|uniq -c |sort -rn| awk &apos;{print $2}&apos; | xargs -I{} cp {} /tmp/echo &quot;后门样本已拷贝到/tmp/目录&quot;elseecho &quot;未检测到HTML恶意代码&quot;fiecho &quot;----------------------检查系统是否存在perl恶意程序----------------------&quot;if find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot; 1&gt;/dev/null 2&gt;&amp;1;thenecho &quot;发现perl恶意程序&quot;find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;|sort -n|uniq -c |sort -rnfind / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;|sort -n|uniq -c |sort -rn| awk &apos;{print $2}&apos; | xargs -I{} cp {} /tmp/echo &quot;可疑样本已拷贝到/tmp/目录&quot;elseecho &quot;未检测到perl恶意程序&quot;fiecho &quot;----------------------检查系统是否存在Python恶意程序----------------------&quot;find / -type f -name *.py | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb&quot; |sort -n|uniq -c |sort -rnfind / -type f -name *.py | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb&quot; |sort -n|uniq -c |sort -rn| awk &apos;{print $2}&apos; | xargs -I{} cp {} /tmp/echo ------------------------------------------------------------------------echo &quot;-----------------------检查系统是否存在恶意程序---------------------&quot;find / -type f -perm -111  |xargs egrep &quot;UpdateProcessER12CUpdateGatesE6C|CmdMsg\.cpp|MiniHttpHelper.cpp|y4&apos;r3 1uCky k1d\!|execve@@GLIBC_2.0|initfini.c|ptmalloc_unlock_all2|_IO_wide_data_2|system@@GLIBC_2.0|socket@@GLIBC_2.0|gettimeofday@@GLIBC_2.0|execl@@GLIBC_2.2.5|WwW.SoQoR.NeT|2.6.17-2.6.24.1.c|Local Root Exploit|close@@GLIBC_2.0|syscall\(\__NR\_vmsplice,|Linux vmsplice Local Root Exploit|It looks like the exploit failed|getting root shell&quot; 2&gt;/dev/nullecho ------------------------------------------------------------------------echo &quot;检查网络连接和监听端口&quot;netstat -an echo &quot;--------------------------路由表、网络连接、接口信息--------------&quot;netstat -rn echo &quot;------------------------查看网卡详细信息--------------------------&quot;ifconfig -a echo ------------------------------------------------------------------------echo &quot;查看正常情况下登录到本机的所有用户的历史记录&quot;lastecho ------------------------------------------------------------------------echo &quot;检查系统中core文件是否开启&quot;ulimit -cecho &quot;core是unix系统的内核。当你的程序出现内存越界的时候,操作系统会中止你的进程,并将当前内存状态倒出到core文件中,以便进一步分析，如果返回结果为0，则是关闭了此功能，系统不会生成core文件&quot;echo ------------------------------------------------------------------------echo &quot;检查系统中关键文件修改时间&quot;ls -ltr /bin/ls /bin/login /etc/passwd /bin/ps /usr/bin/top /etc/shadow|awk &apos;{print &quot;文件名：&quot;$8&quot;  &quot;&quot;最后修改时间：&quot;$6&quot; &quot;$7}&apos;echo &quot;ls文件：是存储ls命令的功能函数，被删除以后，就无法执行ls命令，黑客可利用篡改ls文件来执行后门或其他程序。login文件：login是控制用户登录的文件，一旦被篡改或删除，系统将无法切换用户或登陆用户user/bin/passwd是一个命令，可以为用户添加、更改密码，但是，用户的密码并不保存在/etc/passwd当中，而是保存在了/etc/shadow当中etc/passwd是一个文件，主要是保存用户信息。sbin/portmap是文件转换服务，缺少该文件后，无法使用磁盘挂载、转换类型等功能。bin/ps 进程查看命令功能支持文件，文件损坏或被更改后，无法正常使用ps命令。usr/bin/top  top命令支持文件，是Linux下常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况。etc/shadow shadow 是 /etc/passwd 的影子文件，密码存放在该文件当中，并且只有root用户可读。&quot;echo --------------------------------------------------------------------------echo &quot;-------------------查看系统日志文件是否存在--------------------&quot;log=/var/log/sysloglog2=/var/log/messagesif [ -e &quot;$log&quot; ]; thenecho  &quot;syslog日志文件存在！ &quot;elseecho  &quot;/var/log/syslog日志文件不存在！ &quot;fiif [ -e &quot;$log2&quot; ]; thenecho  &quot;/var/log/messages日志文件存在！ &quot;elseecho  &quot;/var/log/messages日志文件不存在！ &quot;fiecho --------------------------------------------------------------------------echo &quot;检查系统文件完整性2(MD5检查)&quot;echo &quot;该项会获取部分关键文件的MD5值并入库，默认保存在/etc/md5db中&quot;echo &quot;如果第一次执行，则会提示md5sum: /sbin/portmap: 没有那个文件或目录&quot;echo &quot;第二次重复检查时，则会对MD5DB中的MD5值进行匹配，来判断文件是否被更改过&quot;file=&quot;/etc/md5db&quot;if [ -e &quot;$file&quot; ]; then md5sum -c /etc/md5db 2&gt;&amp;1; else md5sum /etc/passwd &gt;&gt;/etc/md5dbmd5sum /etc/shadow &gt;&gt;/etc/md5dbmd5sum /etc/group &gt;&gt;/etc/md5dbmd5sum /usr/bin/passwd &gt;&gt;/etc/md5dbmd5sum /sbin/portmap&gt;&gt;/etc/md5dbmd5sum /bin/login &gt;&gt;/etc/md5dbmd5sum /bin/ls &gt;&gt;/etc/md5dbmd5sum /bin/ps &gt;&gt;/etc/md5dbmd5sum /usr/bin/top &gt;&gt;/etc/md5db;fiecho ----------------------------------------------------------------------echo &quot;------------------------主机性能检查--------------------------------&quot;echo &quot;CPU检查&quot;dmesg | grep -i cpuecho -----------------------------------------------------------------------more /proc/cpuinfoecho -----------------------------------------------------------------------echo &quot;内存状态检查&quot;vmstat 2 5echo -----------------------------------------------------------------------more /proc/meminfoecho -----------------------------------------------------------------------free -mecho -----------------------------------------------------------------------echo &quot;文件系统使用情况&quot;df -hecho -----------------------------------------------------------------------echo &quot;网卡使用情况&quot;lspci -tvecho ----------------------------------------------------------------------echo &quot;查看僵尸进程&quot;ps -ef | grep zombieecho ----------------------------------------------------------------------echo &quot;耗CPU最多的进程&quot;ps auxf |sort -nr -k 3 |head -5echo ----------------------------------------------------------------------echo &quot;耗内存最多的进程&quot;ps auxf |sort -nr -k 4 |head -5echo ----------------------------------------------------------------------echo ---------------------------------------------------------------------echo &quot;COPY RIGHT &quot;echo &quot;QQ：&quot;echo ----------------------结束时间为-------------------------------------DATE=`date`echo &quot;Date is $DATE&quot;echo ----------------------------------------------------------------------</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="shell" scheme="https://architectang.github.io/categories/Linux/shell/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://architectang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>memcache服务器搭建</title>
    <link href="https://architectang.github.io/2018/02/19/memcache%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://architectang.github.io/2018/02/19/memcache服务器搭建/</id>
    <published>2018-02-19T07:13:08.000Z</published>
    <updated>2019-07-13T07:29:58.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="一、memcache简介"><a href="#一、memcache简介" class="headerlink" title="一、memcache简介"></a>一、memcache简介</h5><p>Memcache是什么<br>Memcache是danga.com的一个项目，最早是为 LiveJournal 服务的，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力。<br>它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个HashTable，Memcached自管理这些HashTable。<br><a href="http://www.danga.com/memcached" target="_blank" rel="noopener">Memcache官方网站,更多详细的信息可以来这里了解</a><br>为什么会有Memcache和memcached两种名称？</p><p>其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名。一个是项目名称，一个是主程序文件名，不要混用了。</p><h5 id="二、Memcache的安装"><a href="#二、Memcache的安装" class="headerlink" title="二、Memcache的安装"></a>二、Memcache的安装</h5><p>安装分为两个过程：memcache服务器端的安装和memcached客户端的安装。<br>所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储<br>所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。</p><h6 id="2-1、memcache服务器的安装"><a href="#2-1、memcache服务器的安装" class="headerlink" title="2.1、memcache服务器的安装"></a>2.1、memcache服务器的安装</h6><p>这里安装memcache需要指定libevent，查看系统是否已经安装libevent</p><pre><code>rpm -qa | grep libevent</code></pre><p><img src="https://i.loli.net/2019/07/13/5d2985faafa4b76076.png" alt="查看安装.png"><br>如果已经有，先进行升级</p><pre><code>yum -y  install libevent</code></pre><p>测试libevent是否已经安装成功</p><pre><code>ll /usr/share/doc/ | grep libevent</code></pre><p><img src="https://i.loli.net/2019/07/13/5d29862f7f08f40337.png" alt="安装.png"><br>可以看到有已经安装类包</p><p>进行安装memchache （到官网下载自己需要的软件版本）</p><p>解压文件并将文件移动到 /usr/local/ 目录下<br><img src="https://i.loli.net/2019/07/13/5d2986638e30853604.png" alt="拷贝.png"><br>进入memcache目录进行安装<br><img src="https://i.loli.net/2019/07/13/5d29868c3866d82017.png" alt="mem安装.png"><br>可能会有一个报错<br><img src="https://i.loli.net/2019/07/13/5d2986acb5e6369423.png" alt="报错.png"><br>因为libevent这个包是系统默认安装的，没有安装相应的开发所用的头文件，所以需要使用以下命令进行安装<br><img src="https://i.loli.net/2019/07/13/5d2986d7a4c1853141.png" alt="安装2.png"><br>再次编译即可通过，编译通过后执行 make &amp;&amp; make install命令进行安装<br><img src="https://i.loli.net/2019/07/13/5d2986f97a7fd28819.png" alt="编译.png"><br>启动memcache</p><pre><code>/usr/local/memcached/bin/memcached -d -m 128 -l 172.31.8.50 -p 11211 -u root</code></pre><p><img src="https://i.loli.net/2019/07/13/5d298724a403a65285.png" alt="启动.png"><br>进行连接测试</p><pre><code>telnet 172.31.8.50 11211   #出现以下内容即为安装成功</code></pre><p><img src="https://i.loli.net/2019/07/13/5d2987485992657217.png" alt="测试.png"><br>输出数据的格式如下：</p><pre><code>set foo 0 0 3bar</code></pre><p>如果保存成功，控制台会输出STORED<br><img src="https://i.loli.net/2019/07/13/5d2987839974c66208.png" alt="测试2.png"><br>获取数据的命令格式如下</p><pre><code>get foo</code></pre><p>在控制台的输出信息如下<br><img src="https://i.loli.net/2019/07/13/5d2987ba0cb0731822.png" alt="数据获取.png"><br>链接到memcache后输入stats可以获得包括资源利用率在内的个种信息<br><img src="https://i.loli.net/2019/07/13/5d2987ec23b8b40867.png" alt="status.png"><br>此外输入”stats items”可以获得关于缓存记录的信息，推出程序输入“quit”<br><img src="https://i.loli.net/2019/07/13/5d2988140f63443606.png" alt="缓存信息.png"><br>这些参数的具体含义可以参考下面的列表<br><img src="https://i.loli.net/2019/07/13/5d298837c546c92118.png" alt="参考.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="memcache" scheme="https://architectang.github.io/categories/Linux/memcache/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="memcache" scheme="https://architectang.github.io/tags/memcache/"/>
    
  </entry>
  
  <entry>
    <title>redis集群构建（伪集群）</title>
    <link href="https://architectang.github.io/2018/02/13/redis%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%EF%BC%88%E4%BC%AA%E9%9B%86%E7%BE%A4%EF%BC%89/"/>
    <id>https://architectang.github.io/2018/02/13/redis集群构建（伪集群）/</id>
    <published>2018-02-13T06:38:07.000Z</published>
    <updated>2019-07-13T07:06:29.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>用两个虚拟机模拟6个redis节点，一台机器三个节点，创建3个master、3个salve节点。<br>redis采用3.2.4<br><img src="https://i.loli.net/2019/07/13/5d297ccab7f7684336.png" alt="redis版本.png"><br>两台机器都是centos6.8，分别为172.31.8.102、172.31.8.24</p><h5 id="一、安装过程"><a href="#一、安装过程" class="headerlink" title="一、安装过程"></a>一、安装过程</h5><h6 id="1、下载并解压"><a href="#1、下载并解压" class="headerlink" title="1、下载并解压"></a>1、下载并解压</h6><pre><code>[root@localhost ~]# mkdir /software[root@localhost software]#wget http://download.redis.io/releases/redis-3.2.4.tar.gz[root@localhost software]# tar -zxvf redis-3.2.4.tar.gz</code></pre><h6 id="2、编译安装"><a href="#2、编译安装" class="headerlink" title="2、编译安装"></a>2、编译安装</h6><pre><code>[root@localhost software]# cd redis-3.2.4[root@localhost redis-3.2.4]# make &amp;&amp; make install</code></pre><h6 id="3、将redis-trib-rb-复制到-usr-local-bin"><a href="#3、将redis-trib-rb-复制到-usr-local-bin" class="headerlink" title="3、将redis-trib.rb 复制到/usr/local/bin/"></a>3、将redis-trib.rb 复制到/usr/local/bin/</h6><pre><code>[root@localhost redis-3.2.4]# ll src/redis-trib.rb -rwxrwxr-x. 1 root root 60852 9月  26 2016 src/redis-trib.rb[root@localhost redis-3.2.4]# cp src/redis-trib.rb /usr/local/bin/</code></pre><h6 id="4、创建redis节点"><a href="#4、创建redis节点" class="headerlink" title="4、创建redis节点"></a>4、创建redis节点</h6><p>首先在172.31.8.102节点上/software/redis-3.2.4目录下创建redis_cluster目录</p><pre><code>[root@localhost redis-3.2.4]# mkdir redis_cluster</code></pre><p>在redis_cluster目录下创建7000、7001、7002目录，并把redis.conf文件copy到这三个目录中</p><pre><code>[root@localhost redis_cluster]# mkdir 7000 7001 7002[root@localhost redis-3.2.4]# cp redis.conf redis_cluster/7000/[root@localhost redis-3.2.4]# cp redis.conf redis_cluster/7001/[root@localhost redis-3.2.4]# cp redis.conf redis_cluster/7002/</code></pre><p>分别修改三个文件</p><pre><code>port  7000                                    //端口7000,7002,7003 bind 本机ip                                   //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群daemonize    yes                             //redis后台运行pidfile  /var/run/redis_7000.pid             //pidfile文件对应7000,7001,7002cluster-enabled  yes                         //开启集群  把注释#去掉cluster-config-file  nodes_7000.conf     //集群的配置  配置文件首次启动自动生成 7000,7001,7002cluster-node-timeout  15000              //请求超时  默认15秒，可自行设置appendonly  yes                              //aof日志开启  有需要就开启，它会每次写操作都记录一条日志</code></pre><p>接着在另一台机器上（172.31.8.24）重复操作以上四步，只是把目录改为7003、7004、7005，对应的配置文件也按照相应的规则修改即可</p><h6 id="5、启动各个节点"><a href="#5、启动各个节点" class="headerlink" title="5、启动各个节点"></a>5、启动各个节点</h6><p>在第一台机器上操作</p><pre><code>[root@localhost redis-3.2.4]# redis-server redis_cluster/7000/redis.conf [root@localhost redis-3.2.4]# redis-server redis_cluster/7001/redis.conf [root@localhost redis-3.2.4]# redis-server redis_cluster/7002/redis.conf</code></pre><p>在第二台机器上操作</p><pre><code>[root@localhost redis-3.2.4]# redis-server redis_cluster/7003/redis.conf [root@localhost redis-3.2.4]# redis-server redis_cluster/7004/redis.conf [root@localhost redis-3.2.4]# redis-server redis_cluster/7005/redis.conf</code></pre><h6 id="6、检查redis启动情况"><a href="#6、检查redis启动情况" class="headerlink" title="6、检查redis启动情况"></a>6、检查redis启动情况</h6><p>第一台机器</p><p><img src="https://i.loli.net/2019/07/13/5d297e865aee364106.png" alt="服务器一.png"></p><p>第二台机器</p><p><img src="https://i.loli.net/2019/07/13/5d297ecf7d48657750.png" alt="服务器二.png"></p><h6 id="7、创建集群"><a href="#7、创建集群" class="headerlink" title="7、创建集群"></a>7、创建集群</h6><p>redis官方提供了redis-trib.rb工具，就在已解压的src目录中，第三步已经将它拷贝到了/usr/local/bin/目录中，可以在命令行中使用了，使用以下命令创建集群：<br>使用这个工具需要ruby，使用yum安装即可：</p><pre><code>yum -y install ruby ruby-devel rubygems rpm-build[root@localhost redis-3.2.4]# redis-trib.rb create --replicas 1 172.31.8.102:7000 172.31.8.102:7001 172.31.8.102:7002 172.31.8.24:7003 172.31.8.24:7004 172.31.8.24:7005</code></pre><p><img src="https://i.loli.net/2019/07/13/5d297f38f0ad032213.png" alt="安装.png"><br>前三个IP:port为第一个节点，后面三个为第二个节点</p><p>可能会出现的报错：<br><img src="https://i.loli.net/2019/07/13/5d297f6b6c3cf57598.png" alt="报错.png"><br>这是因为ruby版本较低。yum安装的版本是1.8.7，但是redis需要的是1.9.3或者更高</p><pre><code>[root@localhost bin]# gem sources -a https://ruby.taobao.org/[root@localhost bin]# gem install  redis --version 3.0.0</code></pre><p>之后再运行redis-trib.rb，会出现如下提示：<br><img src="https://i.loli.net/2019/07/13/5d297fa8b3c1977824.png" alt="修复.png"><br>输入“yes”回车即可，然后出现如下内容，说明安装成功<br><img src="https://i.loli.net/2019/07/13/5d297fcd61bc662918.png" alt="安装完成.png"></p><h5 id="二、集群验证"><a href="#二、集群验证" class="headerlink" title="二、集群验证"></a>二、集群验证</h5><p>在第一台机器上连接集群的7002端口的节点，在另外一台连接7005节点，连接方式为 redis-cli -h 172.31.8.102 -c -p 7002,加参数 -c 可连接到集群，因为上面 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略。<br>在7005节点执行命令：<br><img src="https://i.loli.net/2019/07/13/5d29800e3b94634053.png" alt="验证一.png"><br>然后在另外一台7002端口,查看key为hello的内容,get hello,执行结果如下：<br><img src="https://i.loli.net/2019/07/13/5d2980369e6db81631.png" alt="验证二.png"><br>说明集群运作正常</p><h5 id="三、原理简介："><a href="#三、原理简介：" class="headerlink" title="三、原理简介："></a>三、原理简介：</h5><p>redis cluster在设计的时候，就考虑到了去中心化,去中间件,也就是说,集群中的每个节点都是平等的关系,都是对等的,每个节点都保存各自的数据和整个集群的状态,每个节点都和其他所有节点连接而且这些连接保持活跃这样就保证了我们只需要连接集群中的任意一个节点,就可以获取到其他节点的数据.<br>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽(hash slot)方式来分配的。rediscluster默认分配了16384个slot,当我们set一个key时,会用CRC16算法来取模得到所属的slot,然后将这个key 分到哈希槽区间的节点上,具体算法就是：CRC16(key) % 16384,所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点.<br>Redis集群会把数据存在一个master节点,然后在这个master和其对应的salve之间进行数据同步.当读取数据时,也根据一致性哈希算法到对应的master节点获取数据,只有当一个master 挂掉之后，才会启动一个对应的salve节点,充当 master.<br>需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="redis" scheme="https://architectang.github.io/categories/Linux/redis/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
      <category term="redis" scheme="https://architectang.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>批量ping存活主机</title>
    <link href="https://architectang.github.io/2017/11/17/%E6%89%B9%E9%87%8Fping%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA/"/>
    <id>https://architectang.github.io/2017/11/17/批量ping存活主机/</id>
    <published>2017-11-17T04:50:22.000Z</published>
    <updated>2019-07-10T13:14:47.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>创建一个ip.txt文件，把需要测试IP地址写入文档</p><p><img src="https://i.loli.net/2019/05/17/5cde3e1a07bca53225.png" alt="1.png"></p><a id="more"></a><p>创建一个ping.sh 的shell 脚本，并修改ip.txt 文件路径</p><pre><code>#!/bin/bashfor ips in `cat /root/manager/script/ip.txt`do        result=`ping -w 2 -c 3 ${ips} | grep packet | awk -F&quot; &quot; &apos;{print $6}&apos;| awk -F&quot;%&quot; &apos;{print $1}&apos;| awk -F&apos; &apos; &apos;{print $1}&apos;`        if [ $result -eq 0 ]; then                echo &quot;&quot;${ips}&quot; is ok !&quot;        else                echo &quot;&quot;${ips}&quot; is not connected .....&quot;        fidone</code></pre><p>给脚本执行权限 chmod +x ping.sh</p><p>执行脚本</p><pre><code>[root@k8s-node1 script]# ./ping.sh 172.31.8.101 is ok !172.31.8.192 is ok !172.31.8.42 is ok !172.31.8.176 is ok !172.31.8.45 is ok ![root@k8s-node1 script]# </code></pre><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;创建一个ip.txt文件，把需要测试IP地址写入文档&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cde3e1a07bca53225.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="shell" scheme="https://architectang.github.io/categories/Linux/shell/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql性能的检查和调优方法</title>
    <link href="https://architectang.github.io/2017/08/20/mysql%E6%80%A7%E8%83%BD%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95/"/>
    <id>https://architectang.github.io/2017/08/20/mysql性能的检查和调优方法/</id>
    <published>2017-08-20T07:48:11.000Z</published>
    <updated>2019-07-14T13:12:23.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- build time:Wed Jul 17 2019 21:24:47 GMT+0800 (中国标准时间) --><p>我一直是使用mysql这个数据库软件，它工作比较稳定，效率也很高。在遇到严重性能问题时，一般都有这么几种可能：<br>1、索引没有建好；</p><p>2、sql写法过于复杂；</p><p>3、配置错误；</p><p>4、机器实在负荷不了；</p><p>1、索引没有建好</p><p>如果看到mysql消耗的cpu很大，可以用mysql的client工具来检查。</p><p>在linux下执行</p><pre><code>/usr/local/mysql/bin/mysql -hlocalhost -uroot -p</code></pre><p>输入密码，如果没有密码，则不用-p参数就可以进到客户端界面中。</p><p>看看当前的运行情况</p><pre><code>show full processlist</code></pre><p>可以多运行几次</p><p>这个命令可以看到当前正在执行的sql语句，它会告知执行的sql、数据库名、执行的状态、来自的客户端ip、所使用的帐号、运行时间等信息<br>在我的cache后端，这里面大部分时间是看不到显示任何sql语句的，我认为这样才算比较正常。如果看到有很多sql语句，那么这台mysql就一定会有性能问题<br>如果出现了性能问题，则可以进行分析：</p><p>1、是不是有sql语句卡住了？</p><p>这是出现比较多的情况，如果数据库是采用myisam，那么有可能有一个写入的线程会把数据表给锁定了，如果这条语句不结束，则其它语句也无法运行。<br>查看processlist里的time这一项，看看有没有执行时间很长的语句，要留意这些语句。</p><p>2、大量相同的sql语句正在执行</p><p>如果出现这种情况，则有可能是该sql语句执行的效率低下，同样要留意这些语句。<br>然后把你所怀疑的语句统统集合一下，用desc（explain）来检查这些语句。</p><p>首先看看一个正常的desc输出：</p><pre><code>mysql&gt; desc select * from imgs where imgid=1651768337;+—-+————-+——-+——-+—————+———+———+——-+——+——-+| id | select_type | table | type   | possible_keys | key     | key_len | ref   | rows | Extra |+—-+————-+——-+——-+—————+———+———+——-+——+——-+|   1 | SIMPLE       | imgs   | const | PRIMARY       | PRIMARY | 8       | const |     1 |       |+—-+————-+——-+——-+—————+———+———+——-+——+——-+1 row in set (0.00 sec)</code></pre><p>注意key、rows和Extra这三项，这条语句返回的结果说明了该sql会使用PRIMARY主键索引来查询，结果集数量为1条，Extra没有显 示，证明没有用到排序或其他操作。由此结果可以推断，mysql会从索引中查询imgid=1651768337这条记录，然后再到真实表中取出所有字 段，是很简单的操作。<br>key是指明当前sql会使用的索引，mysql执行一条简单语句时只能使用到一条索引，注意这个限制；rows是返回的结果集大小，结果集就是使用该索引进行一次搜索的所有匹配结果；Extra一般会显示查询和排序的方式，。<br>如果没有使用到key，或者rows很大而用到了filesort排序，一般都会影响到效率，例如：</p><pre><code>mysql&gt; desc select * from imgs where userid=”7mini” order by clicks desc limit 10;+—-+————-+——-+——+—————+——+———+——+——-+—————————–+| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows   | Extra                       |+—-+————-+——-+——+—————+——+———+——+——-+—————————–+|   1 | SIMPLE       | imgs   | ALL   | NULL           | NULL | NULL     | NULL | 12506 | Using where; Using filesort |+—-+————-+——-+——+—————+——+———+——+——-+—————————–+1 row in set (0.00 sec)</code></pre><p>这条sql结果集会有12506条，用到了filesort，所以执行起来会非常消耗效率的。这时mysql执行时会把整个表扫描一遍，一条一条去找到匹 配userid=”7mini”的记录，然后还要对这些记录的clicks进行一次排序，效率可想而知。真实执行时如果发现还比较快的话，那是因为服务器 内存还足够将12506条比较短小的记录全部读入内存，所以还比较快，但是并发多起来或者表大起来的话，效率问题就严重了。<br>这时我把userid加入索引：</p><pre><code>create index userid on imgs (userid);</code></pre><p>然后再检查：</p><pre><code>mysql&gt; desc select * from imgs where userid=”7mini” order by clicks desc limit 10;+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | Extra                       |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+|   1 | SIMPLE       | imgs   | ref   | userid         | userid | 51       | const |     8 | Using where; Using filesort |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+1 row in set (0.00 sec)</code></pre><p>嗯，这时可以看到mysql使用了userid这个索引搜索了，用userid索引一次搜索后，结果集有8条。然后虽然使用了filesort一条一条排序，但是因为结果集只有区区8条，效率问题得以缓解。<br>但是，如果我用别的userid查询，结果又会有所不同：</p><pre><code>mysql&gt; desc select * from imgs where userid=”admin” order by clicks desc limit 10;+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | Extra                       |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+|   1 | SIMPLE       | imgs   | ref   | userid         | userid | 51       | const | 2944 | Using where; Using filesort |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+1 row in set (0.00 sec)</code></pre><p>这个结果和userid=”7mini”的结果基本相同，但是mysql用userid索引一次搜索后结果集的大小达到2944条，这2944条记录都会 加入内存进行filesort，效率比起7mini那次来说就差很多了。这时可以有两种办法可以解决，第一种办法是再加一个索引和判断条件，因为我只需要 根据点击量取最大的10条数据，所以有很多数据我根本不需要加进来排序，比如点击量小于10的，这些数据可能占了很大部分。<br>我对clicks加一个索引，然后加入一个where条件再查询：</p><pre><code>create index clicks on imgs(clicks);mysql&gt; desc select * from imgs where userid=”admin” order by clicks desc limit 10;+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | Extra                       |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+|   1 | SIMPLE       | imgs   | ref   | userid,clicks | userid | 51       | const | 2944 | Using where; Using filesort |+—-+————-+——-+——+—————+——–+———+——-+——+—————————–+1 row in set (0.00 sec)</code></pre><p>这时可以看到possible_keys变成了userid,clicks，possible_keys是可以匹配的所有索引，mysql会从 possible_keys中自己判断并取用其中一个索引来执行语句，值得注意的是，mysql取用的这个索引未必是最优化的。这次查询mysql还是使 用userid这个索引来查询的，并没有按照我的意愿，所以结果还是没有什么变化。改一下sql加上use index强制mysql使用clicks索引：</p><pre><code>mysql&gt; desc select * from imgs use index (clicks) where userid=’admin’ and clicks&gt;10 order by clicks desc limit 10+—-+————-+——-+——-+—————+——–+———+——+——+————-+| id | select_type | table | type   | possible_keys | key     | key_len | ref   | rows | Extra       |+—-+————-+——-+——-+—————+——–+———+——+——+————-+|   1 | SIMPLE       | imgs   | range | clicks         | clicks | 4       | NULL | 5455 | Using where |+—-+————-+——-+——-+—————+——–+———+——+——+————-+1 row in set (0.00 sec)</code></pre><p>这时mysql用到了clicks索引进行查询，但是结果集比userid还要大！看来还要再进行限制：</p><pre><code>mysql&gt; desc select * from imgs use index (clicks) where userid=’admin’ and clicks&gt;1000 order by clicks desc limit 10+—-+————-+——-+——-+—————+——–+———+——+——+————-+| id | select_type | table | type   | possible_keys | key     | key_len | ref   | rows | Extra       |+—-+————-+——-+——-+—————+——–+———+——+——+————-+|   1 | SIMPLE       | imgs   | range | clicks         | clicks | 4       | NULL |   312 | Using where |+—-+————-+——-+——-+—————+——–+———+——+——+————-+1 row in set (0.00 sec)</code></pre><p>加到1000的时候结果集变成了312条，排序效率应该是可以接受。<br>不过，采用换索引这种优化方式需要取一个采样点，比如这个例子中的1000这个数字，这样，对userid的每个数值，都要去找一个采样点，这样对程序来 说是很难办的。如果按1000取样的话，那么userid=’7mini’这个例子中，取到的结果将不会是8条，而是2条，给用户造成了困惑。<br>当然还有另一种办法，加入双索引：</p><pre><code>create index userid_clicks on imgs (userid, clicks)mysql&gt; desc select * from imgs where userid=”admin” order by clicks desc limit 10;+—-+————-+——-+——+———————-+—————+———+——-+——+————-+| id | select_type | table | type | possible_keys         | key           | key_len | ref   | rows | Extra       |+—-+————-+——-+——+———————-+—————+———+——-+——+————-+|   1 | SIMPLE       | imgs   | ref   | userid,userid_clicks | userid_clicks | 51       | const | 2944 | Using where |+—-+————-+——-+——+———————-+—————+———+——-+——+————-+1 row in set (0.00 sec)</code></pre><p>这时可以看到，结果集还是2944条，但是Extra中的filesort不见了。这时mysql使用userid_clicks这个索引去查询，这不但 能快速查询到userid=”admin”的所有记录，并且结果是根据clicks排好序的！所以不用再把这个结果集读入内存一条一条排序了，效率上会高 很多。<br>但是用多字段索引这种方式有个问题，如果查询的sql种类很多的话，就得好好规划一下了，否则索引会建得非常多，不但会影响到数据insert和update的效率，而且数据表也容易损坏。<br>以上是对索引优化的办法，因为原因可能会比较复杂，所以写得比较的长，一般好好优化了索引之后，mysql的效率会提升n个档次，从而也不需要考虑增加机器来解决问题了。<br>但是，mysql甚至所有数据库，可能都不好解决limit的问题。在mysql中，limit 0,10只要索引合适，是没有问题的，但是limit 100000,10就会很慢了，因为mysql会扫描排好序的结果，然后找到100000这个点，取出10条返回。要找到100000这个点，就要扫描 100000条记录，这个循环是比较耗时的。不知道会不会有什么好的算法可以优化这个扫描引擎，我冥思苦想也想不出有什么好办法。对于limit，目前直 至比较久远的将来，我想只能通过业务、程序和数据表的规划来优化，我想到的这些优化办法也都还没有一个是万全之策，往后再讨论。</p><p>2、sql写法过于复杂</p><p>sql写法假如用到一些特殊的功能，比如groupby、或者多表联合查询的话，mysql用到什么方式来查询也可以用desc来分析，我这边用复杂sql的情况还不算多，所以不常分析，暂时就没有好的建议。</p><p>3、配置错误</p><p>配置里主要参数是key_buffer、sort_buffer_size/myisam_sort_buffer_size，这两个参数意思是：</p><p>key_buffer=128M：全部表的索引都会尽可能放在这块内存区域内，索引比较大的话就开稍大点都可以，我一般设为128M，有个好的建议是把很少用到并且比较大的表想办法移到别的地方去，这样可以显著减少mysql的内存占用。<br>sort_buffer_size=1M：单个线程使用的用于排序的内存，查询结果集都会放进这内存里，如果比较小，mysql会多放几次，所以稍微开大一点就可以了，重要是优化好索引和查询语句，让他们不要生成太大的结果集。<br>另外一些配置：</p><p>thread_concurrency=8：这个配置标配=cpu数量x2</p><p>interactive_timeout=30</p><p>wait_timeout=30：这两个配置使用10-30秒就可以了，这样会尽快地释放内存资源，注意：一直在使用的连接是不会断掉的，这个配置只是断掉了长时间不动的连接。</p><p>query_cache：这个功能不要使用，现在很多人看到cache这几个字母就像看到了宝贝，这是不唯物主义的。mysql的query_cache 在每次表数据有变化的时候都会重新清理连至该表的所有缓存，如果更新比较频繁，query_cache不但帮不上忙，而且还会对效率影响很大。这个参数只 适合只读型的数据库，如果非要用，也只能用query_cache_type=2自行用SQL_CACHE指定一些sql进行缓存。</p><p>max_connections：默认为100，一般情况下是足够用的，但是一般要开大一点，开到400-600就可以了，能超过600的话一般就有效率问题，得另找对策，光靠增加这个数字不是办法。<br>其它配置可以按默认就可以了，个人觉得问题还不是那么的大，提醒一下：1、配置虽然很重要，但是在绝大部分情况下都不是效率问题的罪魁祸首。2、mysql是一个数据库，对于数据库最重要考究的不应是效率，而是稳定性和数据准确性。</p><p>4、机器实在负荷不了</p><p>如果做了以上调整，服务器还是不能承受，那就只能通过架构级调整来优化了。</p><p>1、mysql同步。</p><p>通过mysql同步功能将数据同步到数台从数据库，由主数据库写入，从数据库提供读取。<br>我个人不是那么乐意使用mysql同步，因为这个办法会增加程序的复杂性，并常常会引起数据方面的错误。在高负荷的服务中，死机了还可以快速重启，但数据错误的话要恢复就比较麻烦。</p><p>2、加入缓存</p><p>加入缓存之后，就可以解决并发的问题，效果很明显。如果是实时系统，可以考虑用刷新缓存方式使缓存保持最新。<br>在前端加入squid的架构比较提倡使用，在命中率比较高的应用中，基本上可以解决问题。<br>如果是在程序逻辑层里面进行缓存，会增加很多复杂性，问题会比较多而且难解决，不建议在这一层面进行调整。</p><p>3、程序架构调整，支持同时连接多个数据库</p><p>如果web加入缓存后问题还是比较严重，只能通过程序架构调整，把应用拆散，用多台的机器同时提供服务。<br>如果拆散的话，对业务是有少许影响，如果业务当中有部分功能必须使用所有的数据，可以用一个完整库+n个分散库这样的架构，每次修改都在完整库和分散库各操作一次，或定期整理完整库。<br>当然，还有一种最笨的，把数据库整个完完整整的做拷贝，然后程序每次都把完整的sql在这些库执行一遍，访问时轮询访问，我认为这样要比mysql同步的方式安全。</p><p>4、使用 mysql proxy 代理</p><p>mysql proxy 可以通过代理把数据库中的各个表分散到数台服务器，但是它的问题是没有能解决热门表的问题，如果热门内容散在多个表中，用这个办法是比较轻松就能解决问题。<br>我没有用过这个软件也没有认真查过，不过我对它的功能有一点点怀疑，就是它怎么实现多个表之间的联合查询？如果能实现，那么效率如何呢？</p><p>5、使用memcachedb</p><p>数据库换用支持mysql的memcachedb，是可以一试的想法，从memcachedb的实现方式和层面来看对数据没有什么影响，不会对用户有什么困扰。<br>为我现在因为数据库方面问题不多，没有试验过这个玩意。不过，只要它支持mysql的大部分主要的语法，而且本身稳定，可用性是无需置疑的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="Mysql" scheme="https://architectang.github.io/categories/Linux/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://architectang.github.io/tags/Mysql/"/>
    
  </entry>
  
</feed>
