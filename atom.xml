<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ArchitecTang Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://architectang.github.io/"/>
  <updated>2019-05-17T05:05:50.378Z</updated>
  <id>https://architectang.github.io/</id>
  
  <author>
    <name>Zhaohu.Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>批量ping存活主机</title>
    <link href="https://architectang.github.io/2019/05/17/%E6%89%B9%E9%87%8Fping%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA/"/>
    <id>https://architectang.github.io/2019/05/17/批量ping存活主机/</id>
    <published>2019-05-17T04:50:22.000Z</published>
    <updated>2019-05-17T05:05:50.378Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>创建一个ip.txt文件，把需要测试IP地址写入文档</p><p><img src="https://i.loli.net/2019/05/17/5cde3e1a07bca53225.png" alt="1.png"></p><a id="more"></a><p>创建一个ping.sh 的shell 脚本，并修改ip.txt 文件路径</p><pre><code>#!/bin/bashfor ips in `cat /root/manager/script/ip.txt`do        result=`ping -w 2 -c 3 ${ips} | grep packet | awk -F&quot; &quot; &apos;{print $6}&apos;| awk -F&quot;%&quot; &apos;{print $1}&apos;| awk -F&apos; &apos; &apos;{print $1}&apos;`        if [ $result -eq 0 ]; then                echo &quot;&quot;${ips}&quot; is ok !&quot;        else                echo &quot;&quot;${ips}&quot; is not connected .....&quot;        fidone</code></pre><p>给脚本执行权限 chmod +x ping.sh</p><p>执行脚本</p><pre><code>[root@k8s-node1 script]# ./ping.sh 172.31.8.101 is ok !172.31.8.192 is ok !172.31.8.42 is ok !172.31.8.176 is ok !172.31.8.45 is ok ![root@k8s-node1 script]# </code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建一个ip.txt文件，把需要测试IP地址写入文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cde3e1a07bca53225.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://architectang.github.io/categories/Linux/"/>
    
      <category term="shell" scheme="https://architectang.github.io/categories/Linux/shell/"/>
    
    
      <category term="Linux" scheme="https://architectang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PTES渗透测试执行标准</title>
    <link href="https://architectang.github.io/2019/05/17/PTES%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/"/>
    <id>https://architectang.github.io/2019/05/17/PTES渗透测试执行标准/</id>
    <published>2019-05-17T02:57:50.000Z</published>
    <updated>2019-05-17T04:47:43.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="渗透测试注意事项："><a href="#渗透测试注意事项：" class="headerlink" title="渗透测试注意事项："></a>渗透测试注意事项：</h5><p>1、不要进行恶意攻击</p><p>2、不要做傻事</p><p>3、在没有获得书面授权时，不要攻击任何目标</p><p>4、考虑清楚攻击将会带来的后果</p><p>4、如果干了非法的事情，记得天网恢恢疏而不漏</p><p><a href="http://www.pentest-standard.org/" target="_blank" rel="noopener">参考官方对于渗透测试执行标准描述（PTES）</a></p><a id="more"></a><h5 id="一：前期交互阶段"><a href="#一：前期交互阶段" class="headerlink" title="一：前期交互阶段"></a>一：前期交互阶段</h5><p>在前期交互阶段，渗透测试团队与客户组织进行交互讨论，最重要的是确定渗透测试的范围、目标、限制条件以及合同细节</p><p>该阶段通常涉及收集客户需求，准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动</p><h5 id="二：情报收集阶段"><a href="#二：情报收集阶段" class="headerlink" title="二：情报收集阶段"></a>二：情报收集阶段</h5><p>在目标范围确定之后，将进入情报搜集（Information Gathering）阶段，渗透团队可以利用各种信息来源与搜集技术方法，尝试更多关于组织网络拓扑、系统配置与安全防御措施的信息。</p><p>渗透测试者可以使用情报搜集方法包括公开来源信息查询、google Hacking 、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。而对目标系统的情报探查能力是渗透者一项非常重要的技能，情报搜集是否充分在很大程度上决定了渗透测的成败，因为如果你遗漏关键的情报信息，你将可能在后面的阶段一无所获。</p><h5 id="三：威胁建模阶段"><a href="#三：威胁建模阶段" class="headerlink" title="三：威胁建模阶段"></a>三：威胁建模阶段</h5><p>在搜集到充分的情报信息之后，渗透测试团队的成员们停下敲击键盘，大家聚到一起针对获取的信息进行威胁建模（Threat Modeling）与攻击规划。这是渗透测试过程中非常重要，但很容易被忽视的一个关键点。<br>通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道。<br>四：漏洞分析阶段<br>在确定出最可行的攻击通道之后，接下来需要考虑该如何取得目标系统的访问控制权，即漏洞分析（Vulnerability Analysis）阶段。<br>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。在该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h5 id="五：渗透攻击阶段"><a href="#五：渗透攻击阶段" class="headerlink" title="五：渗透攻击阶段"></a>五：渗透攻击阶段</h5><p>渗透攻击（Exploitation）是渗透测试过程中最具有魅力的环节。在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现</p><h5 id="六：后渗透攻击阶段"><a href="#六：后渗透攻击阶段" class="headerlink" title="六：后渗透攻击阶段"></a>六：后渗透攻击阶段</h5><p>后渗透攻击（Post Exploitation）是整个渗透测试过程中最能够体现渗透测试团队创造力与技术能力的环节。前面的环节可以说都是在按部就班地完成非常普遍的目标，而在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。<br>在不同的渗透测试场景中，这些攻击目标与途径可能是千变万化的，而设置是否准确并且可行，也取决于团队自身的创新意识、知识范畴、实际经验和技术能力。</p><h5 id="七：报告阶段"><a href="#七：报告阶段" class="headerlink" title="七：报告阶段"></a>七：报告阶段</h5><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告（Reporting）。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><h5 id="渗透术语："><a href="#渗透术语：" class="headerlink" title="渗透术语："></a>渗透术语：</h5><p>渗透攻击（Exploit）</p><p>攻击者利用安全漏洞，所进行的攻击行为，常见的渗透攻击技术包括缓冲区溢出、web应用程序漏洞攻击（SQL注入）、利用配置错误等</p><p>攻击载荷（Payload）</p><p>目标系统在被渗透攻击之后执行的代码</p><p>Shellcode</p><p>在渗透攻击时作为攻击载荷运行的一组机器指令，通常用汇编语言编写</p><p>模块（Module）</p><p>一段软件代码组件</p><p>监听器（Listener）</p><p>用来等待连入网络链接的组件</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;渗透测试注意事项：&quot;&gt;&lt;a href=&quot;#渗透测试注意事项：&quot; class=&quot;headerlink&quot; title=&quot;渗透测试注意事项：&quot;&gt;&lt;/a&gt;渗透测试注意事项：&lt;/h5&gt;&lt;p&gt;1、不要进行恶意攻击&lt;/p&gt;
&lt;p&gt;2、不要做傻事&lt;/p&gt;
&lt;p&gt;3、在没有获得书面授权时，不要攻击任何目标&lt;/p&gt;
&lt;p&gt;4、考虑清楚攻击将会带来的后果&lt;/p&gt;
&lt;p&gt;4、如果干了非法的事情，记得天网恢恢疏而不漏&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.pentest-standard.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考官方对于渗透测试执行标准描述（PTES）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="https://architectang.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="渗透测试" scheme="https://architectang.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息安全" scheme="https://architectang.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="渗透测试" scheme="https://architectang.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>(二)、Ansible在使用过程中出现的错误解决方法</title>
    <link href="https://architectang.github.io/2018/09/02/%E4%BA%8C-%E3%80%81Ansible%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://architectang.github.io/2018/09/02/二-、Ansible在使用过程中出现的错误解决方法/</id>
    <published>2018-09-02T04:47:00.000Z</published>
    <updated>2019-05-16T11:56:43.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-安装完成后允许命令出错"><a href="#1-安装完成后允许命令出错" class="headerlink" title="1.安装完成后允许命令出错"></a>1.安装完成后允许命令出错</h4><pre><code>Traceback (most recent call last):File &quot;/usr/bin/ansible&quot;, line 197, in &lt;module&gt;        (runner, results) = cli.run(options, args)File &quot;/usr/bin/ansible&quot;, line 163, in run        extra_vars=extra_vars,File &quot;/usr/lib/python2.6/site-packages/ansible/runner/__init__.py&quot;, line 233, in __init__        cmd = subprocess.Popen([&apos;ssh&apos;,&apos;-o&apos;,&apos;ControlPersist&apos;], stdout=subprocess.PIPE, stderr=subprocess.PIPE)File &quot;/usr/lib64/python2.6/subprocess.py&quot;, line 639, in __init__        errread, errwrite)File &quot;/usr/lib64/python2.6/subprocess.py&quot;, line 1228, in _execute_child        raise child_exceptionOSError: [Errno 2] No such file or directory</code></pre><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>yum -y install openssh-clients</p><h4 id="2-出现Error-ansible-requires-a-json-module-none-found"><a href="#2-出现Error-ansible-requires-a-json-module-none-found" class="headerlink" title="2.出现Error: ansible requires a json module, none found!"></a>2.出现Error: ansible requires a json module, none found!</h4><pre><code>SSH password:10.0.1.110 | FAILED &gt;&gt; {&quot;failed&quot;: true,&quot;msg&quot;: &quot;Error: ansible requires a json module, nonefound!&quot;,&quot;parsed&quot;: false}</code></pre><h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>python版本过低，可以升级python或者python-simplejson</p><h4 id="3-安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）"><a href="#3-安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）" class="headerlink" title="3.安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）"></a>3.安装完成后链接客户端报错（配图为我在使用ansible推送文件到客户端的时候遇到的，这个客户端是第一次推送）</h4><pre><code>FAILED =&gt; Using a SSH password insteadof a key is not possible because Host Key checking is enabled and sshpass doesnot support this.  Please add this host&apos;sfingerprint to your known_hosts file to manage this host.</code></pre><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>在ansible 服务器上使用ssh 登陆下/etc/ansible/hosts 里面配置的服务器。然后再次使用ansible 去管理就不会报上面的错误了！<br>但这样大批量登陆就麻烦来。因为默认ansible是使用key验证的，如果使用密码登陆的服务器，使用ansible的话，要不修改ansible.cfg配置文件<br>的ask_pass = True给取消注释，要不就在运行命令时候加上-k，这个意思是-k, –ask-pass ask for SSH password。再修改：</p><p>host_key_checking= False即可</p><h4 id="4-如果客户端不在know-hosts里将会报错"><a href="#4-如果客户端不在know-hosts里将会报错" class="headerlink" title="4.如果客户端不在know_hosts里将会报错"></a>4.如果客户端不在know_hosts里将会报错</h4><pre><code>paramiko: The authenticity of host &apos;192.168.24.15&apos;can&apos;t be established.The ssh-rsa key fingerprint is397c139fd4b0d763fcffaee346a4bf6b.Are you sure you want to continueconnecting (yes/no)?</code></pre><h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><p>需要修改ansible.cfg的#host_key_checking= False取消注释</p><h3 id="5-出现FAILED-gt-FAILED-not-a-valid-DSA-private-key-file"><a href="#5-出现FAILED-gt-FAILED-not-a-valid-DSA-private-key-file" class="headerlink" title="5.出现FAILED =&gt; FAILED: not a valid DSA private key file"></a>5.出现FAILED =&gt; FAILED: not a valid DSA private key file</h3><h5 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h5><p>需要你在最后命令内添加参数-k</p><h4 id="6-openssh升级后无法登录报错"><a href="#6-openssh升级后无法登录报错" class="headerlink" title="6.openssh升级后无法登录报错"></a>6.openssh升级后无法登录报错</h4><pre><code>PAM unable todlopen(/lib64/security/pam_stack.so): /lib64/security/pam_stack.so: cannot openshared objectfile: No such file or directory</code></pre><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>sshrpm 升级后会修改/etc/pam.d/sshd 文件。需要升级前备份此文件最后还原即可登录。</p><h4 id="7-第一次系统初始化运行生成本机ansible用户key时报错"><a href="#7-第一次系统初始化运行生成本机ansible用户key时报错" class="headerlink" title="7.第一次系统初始化运行生成本机ansible用户key时报错"></a>7.第一次系统初始化运行生成本机ansible用户key时报错</h4><pre><code>failed: [127.0.0.1] =&gt;{&quot;checksum&quot;: &quot;f5f2f20fc0774be961fffb951a50023e31abe920&quot;,&quot;failed&quot;: true}msg: Aborting, target uses selinux but pythonbindings (libselinux-python) aren&apos;t installed!FATAL: all hosts have already failed –aborting</code></pre><h5 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h5><p>yum -y install libselinux-python</p><p>参考:  <a href="http://blog.csdn.net/longxibendi/article/details/46989735" target="_blank" rel="noopener">http://blog.csdn.net/longxibendi/article/details/46989735</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="自动化" scheme="https://architectang.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="自动化" scheme="https://architectang.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Ansible</title>
    <link href="https://architectang.github.io/2018/09/01/Ansible/"/>
    <id>https://architectang.github.io/2018/09/01/Ansible/</id>
    <published>2018-09-01T09:26:09.000Z</published>
    <updated>2019-03-08T16:21:30.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、ansible介绍：</p><p>Ansible是一款基于Python开发的自动化运维工具，主要是实现批量系统配置、批量程序部署、批量运行命令、批量执行任务等等诸多功能。</p><p>Ansible是一款灵活的开源工具，能够很大程度简化运维中的配置管理与流程控制方式，它利用推送方式对客户系统加以配置，这样所有工作都可在主服务器端完成。<br>Asible是基于模块工作的，其本身没有批量部署的能力，Ansible<del>~</del>一款运维自动化的软件！<br><a id="more"></a><br>1.1特性</p><p>(1)、no agents：不需要在被管控主机上安装任何客户端；</p><p>(2)、no server：无服务器端，使用时直接运行命令即可；</p><p>(3)、modules in any languages：基于模块工作，可使用任意语言开发模块；</p><p>(4)、yaml，not code：使用yaml语言定制剧本playbook；</p><p>(5)、ssh by default：基于SSH工作；</p><p>(6)、strong multi-tier solution：可实现多级指挥。</p><p><img src="/upload/201809/工作特性.jpg" alt="工作特性"></p><p>1.1 优点</p><p>(1)、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</p><p>(2)、批量任务执行可以写成脚本，而且不用分发到远程就可以执行；</p><p>(3)、使用python编写，维护更简单，ruby语法过于复杂；</p><p>(4)、支持sudo。</p><p><img src="/upload/201809/工作机制.png" alt="工作机制"></p><p>2、ansible安装</p><p>安装epel 源：<br>rpm -ivh  <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm" target="_blank" rel="noopener">https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</a></p><p>安装ansible ：<br>yum install ansible -y</p><p>ssh-keygen  生成秘钥文件,如果不想输入密码可以一直回车</p><p>ssh-keygen -t rsa  </p><p>cd /root/.ssh/ &amp;&amp; ll ./*</p><p>配置ansible  的hosts 文件：</p><p>vim /etc/ansible/hosts</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、ansible介绍：&lt;/p&gt;
&lt;p&gt;Ansible是一款基于Python开发的自动化运维工具，主要是实现批量系统配置、批量程序部署、批量运行命令、批量执行任务等等诸多功能。&lt;/p&gt;
&lt;p&gt;Ansible是一款灵活的开源工具，能够很大程度简化运维中的配置管理与流程控制方式，它利用推送方式对客户系统加以配置，这样所有工作都可在主服务器端完成。&lt;br&gt;Asible是基于模块工作的，其本身没有批量部署的能力，Ansible&lt;del&gt;~&lt;/del&gt;一款运维自动化的软件！&lt;br&gt;
    
    </summary>
    
    
      <category term="自动化" scheme="https://architectang.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
</feed>
